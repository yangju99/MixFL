[
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  @Override\n  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  @Override\n  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  @Override\n  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.ClosureCodingConvention",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention()",
    "snippet": "  public ClosureCodingConvention() {\n    this(CodingConventions.getDefault());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.ClosureCodingConvention",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention(CodingConvention)",
    "snippet": "  public ClosureCodingConvention(CodingConvention wrapped) {\n    super(wrapped);\n\n    Set<String> props = Sets.newHashSet(\n        \"superClass_\",\n        \"instance_\",\n        \"getInstance\");\n    props.addAll(wrapped.getIndirectlyDeclaredProperties());\n    indirectlyDeclaredProperties = ImmutableSet.copyOf(props);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.getAssertionFunctions",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getAssertionFunctions()",
    "snippet": "  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        new AssertInstanceofSpec(\"goog.asserts.assertInstanceof\")\n    );\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AssertionFunctionSpec.getFunctionName",
    "class_name": "com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec",
    "signature": "com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec.getFunctionName()",
    "snippet": "    public String getFunctionName() {\n      return functionName;\n    }",
    "comment": "Returns the name of the function. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CodingConventions.getDefault",
    "class_name": "com.google.javascript.jscomp.CodingConventions",
    "signature": "com.google.javascript.jscomp.CodingConventions.getDefault()",
    "snippet": "  public static CodingConvention getDefault() {\n    return new DefaultCodingConvention();\n  }",
    "comment": "Gets the default coding convention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.defineDelegateProxyPrototypeProperties",
    "class_name": "com.google.javascript.jscomp.CodingConventions$DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.CodingConventions$DefaultCodingConvention.defineDelegateProxyPrototypeProperties(JSTypeRegistry,StaticScope,List,Map)",
    "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      // do nothing.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.getIndirectlyDeclaredProperties",
    "class_name": "com.google.javascript.jscomp.CodingConventions$DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.CodingConventions$DefaultCodingConvention.getIndirectlyDeclaredProperties()",
    "snippet": "    @Override\n    public Collection<String> getIndirectlyDeclaredProperties() {\n      return ImmutableList.of();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Proxy.defineDelegateProxyPrototypeProperties",
    "class_name": "com.google.javascript.jscomp.CodingConventions$Proxy",
    "signature": "com.google.javascript.jscomp.CodingConventions$Proxy.defineDelegateProxyPrototypeProperties(JSTypeRegistry,StaticScope,List,Map)",
    "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      nextConvention.defineDelegateProxyPrototypeProperties(\n          registry, scope, delegateProxyPrototypes, delegateCallingConventions);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Proxy.getAssertionFunctions",
    "class_name": "com.google.javascript.jscomp.CodingConventions$Proxy",
    "signature": "com.google.javascript.jscomp.CodingConventions$Proxy.getAssertionFunctions()",
    "snippet": "    @Override\n    public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n      return nextConvention.getAssertionFunctions();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.checkFirstModule",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(List)",
    "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }",
    "comment": " Verifies that at least one module has been provided and that the first one has at least one source code input. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.fillEmptyModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(List)",
    "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }",
    "comment": " Fill any empty modules with a place holder file. It makes any cross module motion easier. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getAllInputsFromModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(List)",
    "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }",
    "comment": " Builds a single list of all module inputs. Verifies that it contains no duplicates. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressible by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(InputId)",
    "snippet": "  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getOptions()",
    "snippet": "  CompilerOptions getOptions() {\n    return options;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeValidator",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeValidator()",
    "snippet": "  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(List,List,CompilerOptions)",
    "snippet": "  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initInputsByIdMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByIdMap()",
    "snippet": "  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initModules(List,List,CompilerOptions)",
    "snippet": "  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job if the sources are in modules. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(List,boolean)",
    "snippet": "  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.putCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.putCompilerInput(InputId,CompilerInput)",
    "snippet": "  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,InputId,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n    this.ast = ast;\n    this.id = inputId;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, boolean isExtern) {\n    this(ast, ast.getInputId(), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceFile)",
    "snippet": "  public CompilerInput(SourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceFile,boolean)",
    "snippet": "  public CompilerInput(SourceFile file, boolean isExtern) {\n    this(new JsAst(file), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    Node root = ast.getAstRoot(compiler);\n    // The root maybe null if the AST can not be created.\n    if (root != null) {\n      Preconditions.checkState(root.isScript());\n      Preconditions.checkNotNull(root.getInputId());\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getInputId",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return id;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return id.getIdName();\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.isExtern",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.isExtern()",
    "snippet": "  public boolean isExtern() {\n    if (ast == null || ast.getSourceFile() == null) {\n      return false;\n    }\n    return ast.getSourceFile().isExtern();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.setCompiler",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setCompiler(AbstractCompiler)",
    "snippet": "  public void setCompiler(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "Sets an abstract compiler for doing parsing. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.setModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setModule(JSModule)",
    "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }",
    "comment": "Sets the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    assumeClosuresOnlyCaptureReferences = false;\n    inlineProperties = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedClassProperties = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    jqueryPass = false;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n    propertyInvalidationErrors = Maps.newHashMap();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    preferLineBreakAtEndOfFile = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n    errorHandler = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
    "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setLanguageIn(LanguageMode)",
    "snippet": "  public void setLanguageIn(LanguageMode languageIn) {\n    this.languageIn = languageIn;\n    this.languageOut = languageIn;\n  }",
    "comment": " Sets how goog.tweak calls are processed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      ComposeWarningsGuard composeGuard = (ComposeWarningsGuard) guard;\n      if (composeGuard.demoteErrors) {\n        this.demoteErrors = composeGuard.demoteErrors;\n      }\n\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(Lists.newArrayList(composeGuard.guards.descendingSet()));\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GuardComparator.compare",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator.compare(WarningsGuard,WarningsGuard)",
    "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.ControlFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(AbstractCompiler,boolean,boolean)",
    "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }",
    "comment": " Constructor.  @param compiler Compiler instance. @param shouldTraverseFunctions Whether functions should be traversed (true by default). @param edgeAnnotations Whether to allow edge annotations. By default, only node annotations are allowed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFallThrough",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(Node)",
    "snippet": "  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }",
    "comment": " Computes the destination node of n when we want to fallthrough into the subtree of n. We don't always create a CFG edge into n itself because of DOs and FORs. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,ControlFlowAnalysis)",
    "snippet": "  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,Node,ControlFlowAnalysis)",
    "snippet": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "comment": " Computes the follow() node of a given node and its parent. There is a side effect when calling this function. If this function computed an edge that exists a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY according to the finallyMap.  @param fromNode The original source node since {@code node} is changed during recursion. @param node The node that follow() should compute. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(Node,Node)",
    "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }",
    "comment": " Connects cfgNode to the proper CATCH block if target subtree might throw an exception. If there are FINALLY blocks reached before a CATCH, it will make the corresponding entry in finallyMap. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.createEdge",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(Node,Branch,Node)",
    "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }",
    "comment": " Connects the two nodes in the control flow graph.  @param fromNode Source. @param toNode Destination. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
    "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleExpr",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleExpr(Node)",
    "snippet": "  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleFunction",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(Node)",
    "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmt",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(Node)",
    "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmtList",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(Node)",
    "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.mayThrowException",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(Node)",
    "snippet": "  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if the subtree might throw an exception. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.prioritizeFromEntryNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(DiGraphNode)",
    "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }",
    "comment": " Given an entry node, find all the nodes reachable from that node and prioritize them. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.process",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.visit",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getOptionalNodeComparator",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getOptionalNodeComparator(boolean)",
    "snippet": "    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getPosition",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getPosition(DiGraphNode)",
    "snippet": "    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }",
    "comment": " Gets the pre-order traversal position of the given node. @return An arbitrary counter used for comparing positions. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.ControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N,boolean,boolean)",
    "snippet": "  ControlFlowGraph(\n      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n    super(nodeAnnotations, edgeAnnotations);\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getEntry",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }",
    "comment": " Gets the entry point of the control flow graph. In general, this should be the beginning of the global script or beginning of a function.  @return The entry point. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getImplicitReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }",
    "comment": " Gets the implicit return node.  @return Return node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.isEnteringNewCfgNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(Node)",
    "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // is bleed into the local scope and parameters has been assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body represent by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Theses control structure is represented by its node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n\n      case Token.FOR:\n        // The FOR(;;) node differs from other control structure in that\n        // it has a initialization and a increment statement. Those\n        // two statements have its corresponding CFG nodes to represent them.\n        // The FOR node represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          // TODO(user): Investigate how we should handle the case where\n          // we have a very complex expression inside the FOR-IN header.\n          return n != parent.getFirstChild();\n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }",
    "comment": " @return True if n should be represented by a new CFG node in the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.DataFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(ControlFlowGraph,JoinOp)",
    "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }",
    "comment": " Constructs a data flow analysis.  <p>Typical usage <pre> DataFlowAnalysis dfa = ... dfa.analyze(); </pre>  {@link #analyze()} annotates the result to the control flow graph by means of {@link DiGraphNode#setAnnotation} without any modification of the graph itself. Additional calls to {@link #analyze()} recomputes the analysis which can be useful if the control flow graph has been modified.  @param targetCfg The control flow graph object that this object performs on. Modification of the graph requires a separate call to {@link #analyze()}.  @see #analyze() ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
    "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }",
    "comment": " Finds a fixed-point solution using at most {@link #MAX_STEPS} iterations.  @see #analyze(int) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
    "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }",
    "comment": " Finds a fixed-point solution. The function has the side effect of replacing the existing node annotations with the computed solutions using {@link com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.  <p>Initially, each node's input and output flow state contains the value given by {@link #createInitialEstimateLattice()} (with the exception of the entry node of the graph which takes on the {@link #createEntryLattice()} value. Each node will use the output state of its predecessor and compute a output state according to the instruction. At that time, any nodes that depends on the node's newly modified output value will need to recompute their output state again. Each step will perform a computation at one node until no extra computation will modify any existing output state anymore.  @param maxSteps Max number of iterations before the method stops and throw a {@link MaxIterationsExceededException}. This will prevent the analysis from going into a infinite loop. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
    "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }",
    "comment": " Returns the control flow graph that this analysis was performed on. Modifications can be done on this graph, however, the only time that the annotations are correct is after {@link #analyze()} is called and before the graph has been modified. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BranchedFlowState.setIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState.setIn(L)",
    "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.flow",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DiGraphNode)",
    "snippet": "    @Override\n    protected final boolean flow(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<L> outBefore = state.out;\n      state.out = branchedFlowThrough(node.getValue(), state.in);\n      Preconditions.checkState(outBefore.size() == state.out.size());\n      for (int i = 0; i < outBefore.size(); i++) {\n        if (!outBefore.get(i).equals(state.out.get(i))) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.initialize",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.initialize()",
    "snippet": "    @Override\n    protected void initialize() {\n      orderedWorkSet.clear();\n      for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n        int outEdgeCount = getCfg().getOutEdges(node.getValue()).size();\n        List<L> outLattices = Lists.newArrayList();\n        for (int i = 0; i < outEdgeCount; i++) {\n          outLattices.add(createInitialEstimateLattice());\n        }\n        node.setAnnotation(new BranchedFlowState<L>(\n            createInitialEstimateLattice(), outLattices));\n        if (node != getCfg().getImplicitReturn()) {\n          orderedWorkSet.add(node);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.isForward",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.isForward()",
    "snippet": "    @Override\n    final boolean isForward() {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.joinInputs",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.joinInputs(DiGraphNode)",
    "snippet": "    @Override\n    protected void joinInputs(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<DiGraphNode<N, Branch>> predNodes =\n          getCfg().getDirectedPredNodes(node);\n      List<L> values = new ArrayList<L>(predNodes.size());\n\n      for (DiGraphNode<N, Branch> predNode : predNodes) {\n        BranchedFlowState<L> predNodeState = predNode.getAnnotation();\n\n        L in = predNodeState.out.get(\n            getCfg().getDirectedSuccNodes(predNode).indexOf(node));\n\n        values.add(in);\n      }\n      if (getCfg().getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else if (!values.isEmpty()) {\n        state.setIn(joinOp.apply(values));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticType[])",
    "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  public Iterable<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterable over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerDeprecatedGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerDeprecatedGroup(String)",
    "snippet": "  static DiagnosticGroup registerDeprecatedGroup(String name) {\n    return registerGroup(name, new DiagnosticGroup(name, UNUSED));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticType[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.equals",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.hashCode",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.FunctionTypeBuilder",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.FunctionTypeBuilder(String,AbstractCompiler,Node,String,Scope)",
    "snippet": "  FunctionTypeBuilder(String fnName, AbstractCompiler compiler,\n      Node errorRoot, String sourceName, Scope scope) {\n    Preconditions.checkNotNull(errorRoot);\n\n    this.fnName = fnName == null ? \"\" : fnName;\n    this.codingConvention = compiler.getCodingConvention();\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.errorRoot = errorRoot;\n    this.sourceName = sourceName;\n    this.compiler = compiler;\n    this.scope = scope;\n  }",
    "comment": " @param fnName The function name. @param compiler The compiler. @param errorRoot The node to associate with any warning generated by this builder. @param sourceName A source name for associating any warnings that we have to emit. @param scope The syntactic scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.addParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.addParameter(FunctionParamBuilder,JSType,boolean,boolean,boolean)",
    "snippet": "  private boolean addParameter(FunctionParamBuilder builder,\n      JSType paramType, boolean warnedAboutArgList,\n      boolean isOptional, boolean isVarArgs) {\n    boolean emittedWarning = false;\n    if (isOptional) {\n      // Remembering that an optional parameter has been encountered\n      // so that if a non optional param is encountered later, an\n      // error can be reported.\n      if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else if (isVarArgs) {\n      if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else {\n      if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {\n        // An optional parameter was seen and this argument is not an optional\n        // or var arg so it is an error.\n        if (builder.hasVarArgs()) {\n          reportWarning(VAR_ARGS_MUST_BE_LAST);\n        } else {\n          reportWarning(OPTIONAL_ARG_AT_END);\n        }\n        emittedWarning = true;\n      }\n    }\n    return emittedWarning;\n  }",
    "comment": " Add a parameter to the param list. @param builder A builder. @param paramType The parameter type. @param warnedAboutArgList Whether we've already warned about arg ordering issues (like if optional args appeared before required ones). @param isOptional Is this an optional parameter? @param isVarArgs Is this a var args parameter? @return Whether a warning was emitted. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.buildAndRegister",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister()",
    "snippet": "  FunctionType buildAndRegister() {\n    if (returnType == null) {\n      // Infer return types.\n      // We need to be extremely conservative about this, because of two\n      // competing needs.\n      // 1) If we infer the return type of f too widely, then we won't be able\n      //    to assign f to other functions.\n      // 2) If we infer the return type of f too narrowly, then we won't be\n      //    able to override f in subclasses.\n      // So we only infer in cases where the user doesn't expect to write\n      // @return annotations--when it's very obvious that the function returns\n      // nothing.\n      if (!contents.mayHaveNonEmptyReturns() &&\n          !contents.mayHaveSingleThrow() &&\n          !contents.mayBeFromExterns()) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred = true;\n      }\n    }\n\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(\n          fnName, contents.getSourceNode());\n      if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(contents.getSourceNode())\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType, returnTypeInferred)\n          .withTypeOfThis(thisType)\n          .withTemplateNames(templateTypeNames)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    if (extendedInterfaces != null) {\n      fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeNames();\n\n    return fnType;\n  }",
    "comment": " Builds the function type, and puts it in the registry. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.getOrCreateConstructor",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getOrCreateConstructor()",
    "snippet": "  private FunctionType getOrCreateConstructor() {\n    FunctionType fnType = typeRegistry.createConstructorType(\n        fnName, contents.getSourceNode(), parametersNode, returnType);\n    JSType existingType = typeRegistry.getType(fnName);\n\n    if (makesStructs) {\n      fnType.setStruct();\n    } else if (makesDicts) {\n      fnType.setDict();\n    }\n    if (existingType != null) {\n      boolean isInstanceObject = existingType.isInstanceType();\n      if (isInstanceObject || fnName.equals(\"Function\")) {\n        FunctionType existingFn =\n            isInstanceObject ?\n            existingType.toObjectType().getConstructor() :\n            typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n\n        if (existingFn.getSource() == null) {\n          existingFn.setSource(contents.getSourceNode());\n        }\n\n        if (!existingFn.hasEqualCallType(fnType)) {\n          reportWarning(TYPE_REDEFINITION, fnName,\n              fnType.toString(), existingFn.toString());\n        }\n\n        return existingFn;\n      } else {\n        // We fall through and return the created type, even though it will fail\n        // to register. We have no choice as we have to return a function. We\n        // issue an error elsewhere though, so the user should fix it.\n      }\n    }\n\n    maybeSetBaseType(fnType);\n\n    if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n      typeRegistry.declareType(fnName, fnType.getInstanceType());\n    }\n    return fnType;\n  }",
    "comment": " Returns a constructor function either by returning it from the registry if it exists or creating and registering a new type. If there is already a type, then warn if the existing type is different than the one we are creating, though still return the existing function if possible.  The primary purpose of this is that registering a constructor will fail for all built-in types that are initialized in {@link JSTypeRegistry}.  We a) want to make sure that the type information specified in the externs file matches what is in the registry and b) annotate the externs with the {@link JSType} from the registry so that there are not two separate JSType objects for one type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.getScopeDeclaredIn",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getScopeDeclaredIn()",
    "snippet": "  private Scope getScopeDeclaredIn() {\n    int dotIndex = fnName.indexOf(\".\");\n    if (dotIndex != -1) {\n      String rootVarName = fnName.substring(0, dotIndex);\n      Var rootVar = scope.getVar(rootVarName);\n      if (rootVar != null) {\n        return rootVar.getScope();\n      }\n    }\n    return scope;\n  }",
    "comment": " The scope that we should declare this function in, if it needs to be declared in a scope. Notice that TypedScopeCreator takes care of most scope-declaring. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferFromOverriddenFunction",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferFromOverriddenFunction(FunctionType,Node)",
    "snippet": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal,\n      // but make them optional.\n      while (oldParams.hasNext()) {\n        paramBuilder.newOptionalParameterFromNode(oldParams.next());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }",
    "comment": " Infer the parameter and return types of a function from the parameter and return types of the function it is overriding.  @param oldType The function being overridden. Does nothing if this is null. @param paramsParent The LP node of the function that we're assigning to. If null, that just means we're not initializing this to a function literal. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferInheritance",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferInheritance(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\n      if (makesStructs && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // implemented interfaces\n      if (isConstructor || isInterface) {\n        implementedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getImplementedInterfaces()) {\n          JSType maybeInterType = t.evaluate(scope, typeRegistry);\n          if (maybeInterType != null &&\n              maybeInterType.setValidator(new ImplementedTypeValidator())) {\n            implementedInterfaces.add((ObjectType) maybeInterType);\n          }\n        }\n      } else if (info.getImplementedInterfaceCount() > 0) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n      }\n\n      // extended interfaces (for interface only)\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferParameterTypes",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferParameterTypes(Node,JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }",
    "comment": " Infer the parameter types from the list of argument names and the doc info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferReturnType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    if (info != null && info.hasReturnType()) {\n      returnType = info.getReturnType().evaluate(scope, typeRegistry);\n      returnTypeInferred = false;\n    }\n\n    return this;\n  }",
    "comment": " Infer the return type from JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferTemplateTypeName",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferTemplateTypeName(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n    if (info != null) {\n      templateTypeNames = info.getTemplateTypeNames();\n      typeRegistry.setTemplateTypeNames(templateTypeNames);\n    }\n    return this;\n  }",
    "comment": " Infer the template type from the doc info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferThisType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info) {\n    ObjectType maybeThisType = null;\n    if (info != null && info.hasThisType()) {\n      maybeThisType = ObjectType.cast(\n          info.getThisType().evaluate(scope, typeRegistry));\n    }\n    if (maybeThisType != null) {\n      thisType = maybeThisType;\n      thisType.setValidator(new ThisTypeValidator());\n    }\n\n    return this;\n  }",
    "comment": " Infers the type of {@code this}. @param info The JSDocInfo for this function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferThisType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(JSDocInfo,JSType)",
    "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {\n    // Look at the @this annotation first.\n    inferThisType(info);\n\n    if (thisType == null) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null && (info == null || !info.hasType())) {\n        thisType = objType;\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infers the type of {@code this}. @param type The type of this if the info is missing. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isFunctionTypeDeclaration",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isFunctionTypeDeclaration(JSDocInfo)",
    "snippet": "  static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n    return info.getParameterCount() > 0 ||\n        info.hasReturnType() ||\n        info.hasThisType() ||\n        info.isConstructor() ||\n        info.isInterface();\n  }",
    "comment": " Determines whether the given JsDoc info declares a function type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isOptionalParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isOptionalParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isOptionalParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isOptionalArg();\n  }",
    "comment": " @return Whether the given param is an optional param. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isVarArgsParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isVarArgsParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isVarArgsParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isVarArgs();\n  }",
    "comment": " Determine whether this is a var args parameter. @return Whether the given param is a var args param. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.maybeSetBaseType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.maybeSetBaseType(FunctionType)",
    "snippet": "  private void maybeSetBaseType(FunctionType fnType) {\n    if (!fnType.isInterface() && baseType != null) {\n      fnType.setPrototypeBasedOn(baseType);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.setContents",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.setContents(FunctionContents)",
    "snippet": "  FunctionTypeBuilder setContents(@Nullable FunctionContents contents) {\n    if (contents != null) {\n      this.contents = contents;\n    }\n    return this;\n  }",
    "comment": " Sets the contents of this function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.getAssignedNameCounts",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.getAssignedNameCounts()",
    "snippet": "    @Override\n    public Multiset<String> getAssignedNameCounts() {\n      return assignedVarNames;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.getEscapedVarNames",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.getEscapedVarNames()",
    "snippet": "    @Override\n    public Iterable<String> getEscapedVarNames() {\n      return escapedVarNames == null\n          ? ImmutableList.<String>of() : escapedVarNames;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.getSourceNode",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.getSourceNode()",
    "snippet": "    @Override\n    public Node getSourceNode() {\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.mayBeFromExterns",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.mayBeFromExterns()",
    "snippet": "    @Override\n    public boolean mayBeFromExterns() {\n      return n.isFromExterns();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.mayHaveNonEmptyReturns",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.mayHaveNonEmptyReturns()",
    "snippet": "    @Override\n    public boolean mayHaveNonEmptyReturns() {\n      return hasNonEmptyReturns;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.mayHaveSingleThrow",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.mayHaveSingleThrow()",
    "snippet": "    @Override\n    public boolean mayHaveSingleThrow() {\n      Node block = n.getLastChild();\n      return block.hasOneChild() && block.getFirstChild().isThrow();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AstFunctionContents.recordAssignedName",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$AstFunctionContents.recordAssignedName(String)",
    "snippet": "    void recordAssignedName(String name) {\n      assignedVarNames.add(name);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownFunctionContents.get",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$UnknownFunctionContents",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$UnknownFunctionContents.get()",
    "snippet": "    static FunctionContents get() {\n      return singleton;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.GoogleCodingConvention",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention()",
    "snippet": "  public GoogleCodingConvention() {\n    this(new ClosureCodingConvention());\n  }",
    "comment": "By default, decorate the ClosureCodingConvention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.GoogleCodingConvention",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention(CodingConvention)",
    "snippet": "  public GoogleCodingConvention(CodingConvention convention) {\n    super(convention);\n  }",
    "comment": "Decorates a wrapped CodingConvention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isOptionalParameter(Node)",
    "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return parameter.getString().startsWith(OPTIONAL_ARG_PREFIX);\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, parameter names beginning with {@code opt_} are treated as optional arguments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isVarArgsParameter(Node)",
    "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return VAR_ARGS_NAME.equals(parameter.getString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.InferJSDocInfo",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.InferJSDocInfo(AbstractCompiler)",
    "snippet": "  InferJSDocInfo(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape(ObjectType,JSDocInfo,String)",
    "snippet": "  private void attachJSDocInfoToNominalTypeOrShape(\n      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n    if (objType.isConstructor() ||\n        objType.isEnumType() ||\n        objType.isInterface()) {\n      // Named types.\n      if (objType.hasReferenceName() &&\n          objType.getReferenceName().equals(qName)) {\n        objType.setJSDocInfo(docInfo);\n\n        if (objType.isConstructor() || objType.isInterface()) {\n          JSType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(\n              docInfo);\n        } else if (objType instanceof EnumType) {\n          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n        }\n      }\n    } else if (!objType.isNativeObjectType() &&\n        objType.isFunctionType()) {\n      // Structural functions.\n      objType.setJSDocInfo(docInfo);\n    }\n  }",
    "comment": " Handle cases #1 and #3 in the class doc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.dereferenceToObject",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.dereferenceToObject(JSType)",
    "snippet": "  private ObjectType dereferenceToObject(JSType type) {\n    return ObjectType.cast(type == null ? null : type.dereference());\n  }",
    "comment": " Dereferences the given type to an object, or returns null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.process",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      inExterns = false;\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.visit",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSDocInfo docInfo;\n\n    switch (n.getType()) {\n      // Infer JSDocInfo on types of all type declarations on variables.\n      case Token.NAME:\n        if (parent == null) {\n          return;\n        }\n\n        // Only allow JSDoc on VARs, function declarations, and assigns.\n        if (!parent.isVar() &&\n            !NodeUtil.isFunctionDeclaration(parent) &&\n            !(parent.isAssign() &&\n              n == parent.getFirstChild())) {\n          return;\n        }\n\n        // There are four places the doc info could live.\n        // 1) A FUNCTION node.\n        // /** ... */ function f() { ... }\n        // 2) An ASSIGN parent.\n        // /** ... */ x = function () { ... }\n        // 3) A NAME parent.\n        // var x, /** ... */ y = function() { ... }\n        // 4) A VAR gramps.\n        // /** ... */ var x = function() { ... }\n        docInfo = n.getJSDocInfo();\n        if (docInfo == null &&\n            !(parent.isVar() &&\n                !parent.hasOneChild())) {\n          docInfo = parent.getJSDocInfo();\n        }\n\n        // Try to find the type of the NAME.\n        JSType varType = n.getJSType();\n        if (varType == null && parent.isFunction()) {\n          varType = parent.getJSType();\n        }\n\n        // If we have no type to attach JSDocInfo to, then there's nothing\n        // we can do.\n        if (varType == null || docInfo == null) {\n          return;\n        }\n\n        // Dereference the type. If the result is not an object, or already\n        // has docs attached, then do nothing.\n        ObjectType objType = dereferenceToObject(varType);\n        if (objType == null || objType.getJSDocInfo() != null) {\n          return;\n        }\n\n        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n        break;\n\n      case Token.GETPROP:\n        // Infer JSDocInfo on properties.\n        // There are two ways to write doc comments on a property.\n        //\n        // 1)\n        // /** @deprecated */\n        // obj.prop = ...\n        //\n        // 2)\n        // /** @deprecated */\n        // obj.prop;\n        if (parent.isExprResult() ||\n            (parent.isAssign() &&\n             parent.getFirstChild() == n)) {\n          docInfo = n.getJSDocInfo();\n          if (docInfo == null) {\n            docInfo = parent.getJSDocInfo();\n          }\n          if (docInfo != null) {\n            ObjectType lhsType =\n                dereferenceToObject(n.getFirstChild().getJSType());\n            if (lhsType != null) {\n              // Put the JSDoc in the property slot, if there is one.\n              String propName = n.getLastChild().getString();\n              if (lhsType.hasOwnProperty(propName)) {\n                lhsType.setPropertyJSDocInfo(propName, docInfo);\n              }\n\n              // Put the JSDoc in any constructors or function shapes as well.\n              ObjectType propType =\n                  dereferenceToObject(lhsType.getPropertyType(propName));\n              if (propType != null) {\n                attachJSDocInfoToNominalTypeOrShape(\n                    propType, docInfo, n.getQualifiedName());\n              }\n            }\n          }\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(SourceFile)",
    "snippet": "  public void add(SourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp.apply(L,L)",
    "snippet": "    abstract L apply(L latticeA, L latticeB);",
    "comment": " Creates a new lattice that will be the join of two input lattices.  @return The join of {@code latticeA} and {@code latticeB}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp.apply(List)",
    "snippet": "    @Override\n    public final L apply(List<L> values) {\n      Preconditions.checkArgument(!values.isEmpty());\n      int size = values.size();\n      if (size == 1) {\n        return values.get(0);\n      } else if (size == 2) {\n        return apply(values.get(0), values.get(1));\n      } else {\n        int mid = computeMidPoint(size);\n        return apply(\n            apply(values.subList(0, mid)),\n            apply(values.subList(mid, size)));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.inputId = new InputId(sourceFile.getName());\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n      root.setInputId(inputId);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getInputId",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getSourceFile",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
    "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler)",
    "snippet": "  private void parse(AbstractCompiler compiler) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceFile.getName());\n      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(FlatFlowScopeCache)",
    "snippet": "  LinkedFlowScope(FlatFlowScopeCache cache) {\n    this(cache, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(LinkedFlowScope)",
    "snippet": "  LinkedFlowScope(LinkedFlowScope directParent) {\n    this(directParent.cache, directParent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.createChildFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createChildFlowScope()",
    "snippet": "  @Override\n  public FlowScope createChildFlowScope() {\n    frozen = true;\n\n    if (depth > MAX_DEPTH) {\n      if (flattened == null) {\n        flattened = new FlatFlowScopeCache(this);\n      }\n      return new LinkedFlowScope(flattened);\n    }\n\n    return new LinkedFlowScope(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createEntryLattice(Scope)",
    "snippet": "  public static LinkedFlowScope createEntryLattice(Scope scope) {\n    return new LinkedFlowScope(new FlatFlowScopeCache(scope));\n  }",
    "comment": " Creates an entry lattice for the flow. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.equals",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate through all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getFunctionScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getFunctionScope()",
    "snippet": "  private Scope getFunctionScope() {\n    return cache.functionScope;\n  }",
    "comment": "Gets the function scope for this flow scope. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getSlot(String)",
    "snippet": "  @Override\n  public StaticSlot<JSType> getSlot(String name) {\n    if (cache.dirtySymbols.contains(name)) {\n      for (LinkedFlowSlot slot = lastSlot;\n           slot != null; slot = slot.parent) {\n        if (slot.getName().equals(name)) {\n          return slot;\n        }\n      }\n    }\n    return cache.getSlot(name);\n  }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getTypeOfThis",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getTypeOfThis()",
    "snippet": "  @Override\n  public JSType getTypeOfThis() {\n    return cache.functionScope.getTypeOfThis();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.inferQualifiedSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferQualifiedSlot(Node,String,JSType,JSType)",
    "snippet": "  @Override\n  public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n      JSType inferredType) {\n    Scope functionScope = getFunctionScope();\n    if (functionScope.isLocal()) {\n      if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {\n        functionScope.declare(symbol, node, bottomType, null);\n      }\n\n      inferSlotType(symbol, inferredType);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.inferSlotType",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferSlotType(String,JSType)",
    "snippet": "  @Override\n  public void inferSlotType(String symbol, JSType type) {\n    Preconditions.checkState(!frozen);\n    lastSlot = new LinkedFlowSlot(symbol, type, lastSlot);\n    depth++;\n    cache.dirtySymbols.add(symbol);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.optimize",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.optimize()",
    "snippet": "  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }",
    "comment": "a findUniqueRefinedSlot on it.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FlatFlowScopeCache.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache.getSlot(String)",
    "snippet": "    public StaticSlot<JSType> getSlot(String name) {\n      if (symbols.containsKey(name)) {\n        return symbols.get(name);\n      } else {\n        return functionScope.getSlot(name);\n      }\n    }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MemoizedScopeCreator.MemoizedScopeCreator",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.MemoizedScopeCreator(ScopeCreator)",
    "snippet": "  MemoizedScopeCreator(ScopeCreator delegate) {\n    this.delegate = delegate;\n  }",
    "comment": " @param delegate The real source of Scope objects. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MemoizedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getCurrentNode",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getCurrentNode()",
    "snippet": "  public Node getCurrentNode() {\n    return curNode;\n  }",
    "comment": "Returns the node currently being traversed. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getInput",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
    "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(inputId);\n  }",
    "comment": " Gets the current input source. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getInputId",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getInputId()",
    "snippet": "  InputId getInputId() {\n    return inputId;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeDepth",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
    "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
    "snippet": "  public String getSourceName() {\n    return sourceName;\n  }",
    "comment": " Gets the current input source name.  @return A string that may be empty, but not null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.inGlobalScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
    "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }",
    "comment": " Determines whether the traversal is currently in the global scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Scope)",
    "snippet": "  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(AbstractCompiler,List,Callback)",
    "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }",
    "comment": " Traverses a list of node trees. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(List)",
    "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseWithScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseWithScope(Node,Scope)",
    "snippet": "  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    inputId = null;\n    sourceName = \"\";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }",
    "comment": " Traverses a parse tree recursively with a scope, starting with the given root. This should only be used in the global scope. Otherwise, use {@link #traverseAtScope}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopedCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractScopedCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractScopedCallback.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopedCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractScopedCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractScopedCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractShallowStatementCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowStatementCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowStatementCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getBestJSDocInfo",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getBestJSDocInfo(Node)",
    "snippet": "  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return parent.getJSDocInfo();\n      } else if (isObjectLitKey(parent, parent.getParent())) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      }\n    }\n    return info;\n  }",
    "comment": "Find the best JSDoc for the given node. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getBestLValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValue(Node)",
    "snippet": "  static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parent.isName()) {\n      return parent;\n    } else if (parent.isAssign()) {\n      return parent.getFirstChild();\n    } else if (isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    } else if (\n        (parent.isHook() && parent.getFirstChild() != n) ||\n        parent.isOr() ||\n        parent.isAnd() ||\n        (parent.isComma() && parent.getFirstChild() != n)) {\n      return getBestLValue(parent);\n    }\n    return null;\n  }",
    "comment": "Find the l-value that the given r-value is being assigned to. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getBestLValueName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueName(Node)",
    "snippet": "  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }",
    "comment": "Get the name of the given l-value node. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getBestLValueOwner",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueOwner(Node)",
    "snippet": "  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }",
    "comment": "Get the owner of the given l-value node. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getFunctionJSDocInfo",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionJSDocInfo(Node)",
    "snippet": "  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.isFunction());\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.isName()) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }",
    "comment": " Get the JSDocInfo for a function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getInputId",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInputId(Node)",
    "snippet": "  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }",
    "comment": " @param n The node. @return The InputId property on the node or its ancestors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getRValueOfLValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getRValueOfLValue(Node)",
    "snippet": "  static Node getRValueOfLValue(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.ASSIGN:\n        return n.getNext();\n      case Token.VAR:\n        return n.getFirstChild();\n      case Token.FUNCTION:\n        return parent;\n    }\n    return null;\n  }",
    "comment": "Gets the r-value of a node returned by getBestLValue. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getSourceName(Node)",
    "snippet": "  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }",
    "comment": " @param n The node. @return The source name property on the node or its ancestors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getStringValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getStringValue(Node)",
    "snippet": "  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.STRING_KEY:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n        return \"false\";\n\n      case Token.TRUE:\n        return \"true\";\n\n      case Token.NULL:\n        return \"null\";\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }",
    "comment": " Gets the value of a node as a String, or null if it cannot be converted. When it returns a non-null String, this method effectively emulates the <code>String()</code> JavaScript cast function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isAssignmentOp",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp(Node)",
    "snippet": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isBleedingFunctionName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isBleedingFunctionName(Node)",
    "snippet": "  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }",
    "comment": " Returns whether this is a bleeding function (an anonymous named function that bleeds into the inner scope). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isForIn",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isForIn(Node)",
    "snippet": "  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }",
    "comment": " @return Whether the node represents a FOR-IN loop. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(Node)",
    "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }",
    "comment": " Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see {@link #isFunctionExpression}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionExpression",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(Node)",
    "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an function expression? An function expression is one that has either no name or a name that is not added to the current scope.  <p>Some examples of function expressions: <pre> (function () {}) (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> expressions: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A node @return Whether n is an function used within an expression. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isGet",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGet(Node)",
    "snippet": "  static boolean isGet(Node n) {\n    return n.isGetProp() || n.isGetElem();\n  }",
    "comment": " Is this a GETPROP or GETELEM node? ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isHoistedFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(Node)",
    "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }",
    "comment": " Is this node a hoisted function declaration? A function declaration in the scope root is hoisted to the top of the scope. See {@link #isFunctionDeclaration}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLValue(Node)",
    "snippet": "  static boolean isLValue(Node n) {\n    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n        n.isGetElem());\n    Node parent = n.getParent();\n    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n        || parent.isVar()\n        || (parent.isFunction() && parent.getFirstChild() == n)\n        || parent.isDec()\n        || parent.isInc()\n        || parent.isParamList()\n        || parent.isCatch();\n  }",
    "comment": " Determines whether this node is used as an L-value. Notice that sometimes names are used as both L-values and R-values.  We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you treat it as \"assignment to 'undefined' at the top of the scope\". But if we're honest with ourselves, it doesn't make sense, and we only do this because it makes sense to treat this as syntactically similar to \"var x = 0;\".  @param n The node @return True if n is an L-value. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isObjectLitKey",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(Node,Node)",
    "snippet": "  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }",
    "comment": " Determines whether a node represents an object literal key (e.g. key1 in {key1: value1, key2: value2}).  @param node A node @param parent The node's parent ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementParent",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(Node)",
    "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateDispatchers",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateDispatchers(Node,Node)",
    "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.isFunction());\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.isAssign()) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }",
    "comment": " Translate dispatcher info into the property expected node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateFunctions",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateFunctions(Node,Node)",
    "snippet": "    private void annotateFunctions(Node n, Node parent) {\n      JSDocInfo fnInfo = NodeUtil.getFunctionJSDocInfo(n);\n\n      // Compute which function parameters are optional and\n      // which are var_args.\n      Node args = n.getFirstChild().getNext();\n      for (Node arg = args.getFirstChild();\n           arg != null;\n           arg = arg.getNext()) {\n        String argName = arg.getString();\n        JSTypeExpression typeExpr = fnInfo == null ?\n            null : fnInfo.getParameterType(argName);\n\n        if (convention.isOptionalParameter(arg) ||\n            typeExpr != null && typeExpr.isOptionalArg()) {\n          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n        }\n        if (convention.isVarArgsParameter(arg) ||\n            typeExpr != null && typeExpr.isVarArgs()) {\n          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n        }\n      }\n    }",
    "comment": " Annotate optional and var_arg function parameters. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.rhino.head.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,ObjectType)",
    "snippet": "  Scope(Node rootNode, ObjectType thisType) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    this.thisType = thisType;\n    this.isBottom = true;\n    this.depth = 0;\n  }",
    "comment": " Creates a empty Scope (bottom of the lattice). @param rootNode Typically a FUNCTION node or the global BLOCK node. @param thisType the type of {@code this} in this scope ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType.isFunctionType()) {\n      thisType = nodeType.toMaybeFunctionType().getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input);\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getDeclarativelyUnboundVarsWithoutTypes",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getDeclarativelyUnboundVarsWithoutTypes()",
    "snippet": "  public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() {\n    return Iterators.filter(\n        getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n  }",
    "comment": " Gets all variables declared with \"var\" but without declared types attached. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getParentScope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParentScope()",
    "snippet": "  @Override\n  public StaticScope<JSType> getParentScope() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getRootNode",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
    "snippet": "  @Override\n  public Node getRootNode() {\n    return rootNode;\n  }",
    "comment": " Gets the container node of the scope. This is typically the FUNCTION node or the global BLOCK/SCRIPT node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getSlot",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getSlot(String)",
    "snippet": "  @Override\n  public Var getSlot(String name) {\n    return getVar(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getTypeOfThis",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getTypeOfThis()",
    "snippet": "  @Override\n  public ObjectType getTypeOfThis() {\n    return thisType;\n  }",
    "comment": " Gets the type of {@code this} in the current scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVars",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVars()",
    "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }",
    "comment": " Return an iterator over all of the variables declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isBottom",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isBottom()",
    "snippet": "  boolean isBottom() {\n    return isBottom;\n  }",
    "comment": "Whether this is the bottom of the lattice. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Scope.undeclare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.undeclare(Var)",
    "snippet": "  void undeclare(Var var) {\n    Preconditions.checkState(var.scope == this);\n    Preconditions.checkState(vars.get(var.name) == var);\n    vars.remove(var.name);\n  }",
    "comment": " Undeclares a variable, to be used when the compiler optimizes out a variable and removes it from the scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getInitialValue",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getInitialValue()",
    "snippet": "    public Node getInitialValue() {\n      return NodeUtil.getRValueOfLValue(nameNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getName",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getName()",
    "snippet": "    @Override\n    public String getName() {\n      return name;\n    }",
    "comment": " Gets the name of the variable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getNameNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getNameNode()",
    "snippet": "    public Node getNameNode() {\n      return nameNode;\n    }",
    "comment": " Returns the name node that produced this variable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getScope",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getScope()",
    "snippet": "    Scope getScope() {\n      return scope;\n    }",
    "comment": " Gets the scope where this variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.getType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getType()",
    "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }",
    "comment": " Gets this variable's type. To know whether this type has been inferred, see {@code #isTypeInferred()}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.isExtern",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isExtern()",
    "snippet": "    boolean isExtern() {\n      return input == null || input.isExtern();\n    }",
    "comment": " Returns whether this is defined in an extern file. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isLocal()",
    "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }",
    "comment": " Returns whether this is a local variable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.isTypeInferred",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isTypeInferred()",
    "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return typeInferred;\n    }",
    "comment": " Returns whether this variable's type is inferred. To get the variable's type, see {@link #getType()}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.markAssignedExactlyOnce",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.markAssignedExactlyOnce()",
    "snippet": "    void markAssignedExactlyOnce() {\n      markedAssignedExactlyOnce = true;\n    }",
    "comment": " Record that this is assigned exactly once..  In other words, it's assigned in an inner scope so that it's much harder to make assertions about its value at a given point. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.resolveType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.resolveType(ErrorReporter)",
    "snippet": "    void resolveType(ErrorReporter errorReporter) {\n      if (type != null) {\n        type = type.resolve(errorReporter, scope);\n      }\n    }",
    "comment": " Resolve this variable's type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Var.setType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.setType(JSType)",
    "snippet": "    void setType(JSType type) {\n      Preconditions.checkState(isTypeInferred());\n      this.type = type;\n    }",
    "comment": " Sets this variable's type. @throws IllegalStateException if the variable's type is not inferred ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.builder",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.builder()",
    "snippet": "  public static Builder builder() {\n    return new Builder();\n  }",
    "comment": "Create a new builder for source files. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return builder().buildFromCode(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.isExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.isExtern()",
    "snippet": "  @Override\n  public boolean isExtern() {\n    return isExternFile;\n  }",
    "comment": "Returns whether this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setIsExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
    "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }",
    "comment": "Sets that this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Builder.buildFromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile$Builder",
    "signature": "com.google.javascript.jscomp.SourceFile$Builder.buildFromCode(String,String)",
    "snippet": "    public SourceFile buildFromCode(String fileName, String code) {\n      return new Preloaded(fileName, originalPath, code);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressibleGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressibleGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressible groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    inputId = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    inputId = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Node)",
    "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.isName());\n\n    CompilerInput input = compiler.getInput(inputId);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
    "comment": " Declares a variable.  @param n The node corresponding to the variable name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.isFunction()) {\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n        // TODO(johnlenz): inputId maybe null if the FUNCTION node is detached\n        // from the AST.\n        // Is it meaningful to build a scope for detached FUNCTION node?\n      }\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.isParamList());\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.isName());\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().isName());\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        inputId = n.getInputId();\n        Preconditions.checkNotNull(inputId);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.TypeCheck",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(AbstractCompiler,ReverseAbstractInterpreter,JSTypeRegistry,CheckLevel,CheckLevel)",
    "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n        reportMissingOverride, reportUnknownTypes);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.TypeCheck",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(AbstractCompiler,ReverseAbstractInterpreter,JSTypeRegistry,Scope,ScopeCreator,CheckLevel,CheckLevel)",
    "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      ScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.check",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.check(Node,boolean)",
    "snippet": "  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkDeclaredPropertyInheritance",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkDeclaredPropertyInheritance(NodeTraversal,Node,FunctionType,String,JSDocInfo,JSType)",
    "snippet": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getInstanceType().hasProperty(propertyName);\n    boolean superClassHasDeclaredProperty = superClass != null &&\n        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n\n    // For interface\n    boolean superInterfaceHasProperty = false;\n    boolean superInterfaceHasDeclaredProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfaceHasProperty =\n            superInterfaceHasProperty ||\n            interfaceType.hasProperty(propertyName);\n        superInterfaceHasDeclaredProperty =\n            superInterfaceHasDeclaredProperty ||\n            interfaceType.isPropertyTypeDeclared(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty ||\n            interfaceHasProperty;\n        if (reportMissingOverride.isOn()\n            && !declaredOverride\n            && interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    boolean declaredLocally =\n        ctorType.isConstructor() &&\n        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n         ctorType.getInstanceType().hasOwnProperty(propertyName));\n    if (reportMissingOverride.isOn()\n        && !declaredOverride\n        && superClassHasDeclaredProperty\n        && declaredLocally) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n\n    // @override is present and we have to check that it is ok\n    if (superClassHasDeclaredProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getInstanceType().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfaceHasDeclaredProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n              interfaceType.getPropertyType(propertyName);\n          if (!propertyType.canAssignTo(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }",
    "comment": " Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkEnumAlias",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkEnumAlias(NodeTraversal,JSDocInfo,Node)",
    "snippet": "  private void checkEnumAlias(\n      NodeTraversal t, JSDocInfo declInfo, Node value) {\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n      return;\n    }\n\n    JSType valueType = getJSType(value);\n    if (!valueType.isEnumType()) {\n      return;\n    }\n\n    EnumType valueEnumType = valueType.toMaybeEnumType();\n    JSType valueEnumPrimitiveType =\n        valueEnumType.getElementsType().getPrimitiveType();\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n        \"incompatible enum element types\");\n  }",
    "comment": " <p>Checks enum aliases.  <p>We verify that the enum element type of the enum used for initialization is a subtype of the enum element type of the enum the value is being copied in.</p>  <p>Example:</p> <pre>var myEnum = myOtherEnum;</pre>  <p>Enum aliases are irregular, so we need special code for this :(</p>  @param value the value used for initialization of the enum ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkNoTypeCheckSection",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkNoTypeCheckSection(Node,boolean)",
    "snippet": "  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkPropertyAccess",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyAccess(JSType,String,NodeTraversal,Node)",
    "snippet": "  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    // If the property type is unknown, check the object type to see if it\n    // can ever be defined. We explicitly exclude CHECKED_UNKNOWN (for\n    // properties where we've checked that it exists, or for properties on\n    // objects that aren't in this binary).\n    JSType propType = getJSType(n);\n    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n      childType = childType.autobox();\n      ObjectType objectType = ObjectType.cast(childType);\n      if (objectType != null) {\n        // We special-case object types so that checks on enums can be\n        // much stricter, and so that we can use hasProperty (which is much\n        // faster in most cases).\n        if (!objectType.hasProperty(propName) ||\n            objectType.isEquivalentTo(\n                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n          if (objectType instanceof EnumType) {\n            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n          } else {\n            checkPropertyAccessHelper(objectType, propName, t, n);\n          }\n        }\n\n      } else {\n        checkPropertyAccessHelper(childType, propName, t, n);\n      }\n    }\n  }",
    "comment": " Emit a warning if we can prove that a property cannot possibly be defined on an object. Note the difference between JS and a strictly statically typed language: we're checking if the property cannot be defined*, whereas a java compiler would check if the property *can be undefined*. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkPropertyInheritanceOnGetpropAssign",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyInheritanceOnGetpropAssign(NodeTraversal,Node,Node,String,JSDocInfo,JSType)",
    "snippet": "  private void checkPropertyInheritanceOnGetpropAssign(\n      NodeTraversal t, Node assign, Node object, String property,\n      JSDocInfo info, JSType propertyType) {\n    // Inheritance checks for prototype properties.\n    //\n    // TODO(nicksantos): This isn't the right place to do this check. We\n    // really want to do this when we're looking at the constructor.\n    // We'd find all its properties and make sure they followed inheritance\n    // rules, like we currently do for @implements to make sure\n    // all the methods are implemented.\n    //\n    // As-is, this misses many other ways to override a property.\n    //\n    // object.prototype.property = ...;\n    if (object.isGetProp()) {\n      Node object2 = object.getFirstChild();\n      String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n      if (\"prototype\".equals(property2)) {\n        JSType jsType = getJSType(object2);\n        if (jsType.isFunctionType()) {\n          FunctionType functionType = jsType.toMaybeFunctionType();\n          if (functionType.isConstructor() || functionType.isInterface()) {\n            checkDeclaredPropertyInheritance(\n                t, assign, functionType, property, info, propertyType);\n          }\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.doPercentTypedAccounting",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.doPercentTypedAccounting(NodeTraversal,Node)",
    "snippet": "  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }",
    "comment": " Counts the given node in the typed statistics. @param n a node that should be typed ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }",
    "comment": " Ensure that the given node has a type. If it does not have one, attach the UNKNOWN_TYPE. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSType)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(!n.isFunction() ||\n            type.isFunctionType() ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.isGetProp() ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }",
    "comment": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSTypeNative)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.hasUnknownOrEmptySupertype",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.hasUnknownOrEmptySupertype(FunctionType)",
    "snippet": "  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    // The type system should notice inheritance cycles on its own\n    // and break the cycle.\n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }",
    "comment": " Given a constructor or an interface type, find out whether the unknown type is a supertype of the current type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.process",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }",
    "comment": " Main entry point for this phase of processing. This follows the pattern for JSCompiler phases.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.processForTesting",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.processForTesting(Node,Node)",
    "snippet": "  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }",
    "comment": "Main entry point of this phase for testing code. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.propertyIsImplicitCast",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.propertyIsImplicitCast(ObjectType,String)",
    "snippet": "  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Returns true if any type in the chain has an implicitCast annotation for the given property. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // normal type checking\n        final Scope outerScope = t.getScope();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            // Ideally, we would want to check whether the type in the scope\n            // differs from the type being defined, but then the extern\n            // redeclarations of built-in types generates spurious warnings.\n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        // TODO(user): Only traverse the function's body. The function's\n        // name and arguments are traversed by the scope creator, and ideally\n        // should not be traversed by the type checker.\n        break;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visit",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        typeable = false;\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.STRING_KEY:\n        typeable = false;\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE: {\n        left = n.getFirstChild();\n        right = n.getLastChild();\n\n        if (left.isTypeOf()) {\n          if (right.isString()) {\n            checkTypeofString(t, right, right.getString());\n          }\n        } else if (right.isTypeOf() && left.isString()) {\n          checkTypeofString(t, left, left.getString());\n        }\n\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n\n        // We do not want to warn about explicit comparisons to VOID. People\n        // often do this if they think their type annotations screwed up.\n        //\n        // We do want to warn about cases where people compare things like\n        // (Array|null) == (Function|null)\n        // because it probably means they screwed up.\n        //\n        // This heuristic here is not perfect, but should catch cases we\n        // care about without too many false negatives.\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n\n        TernaryValue result = TernaryValue.UNKNOWN;\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n          if (n.isNE()) {\n            result = result.not();\n          }\n        } else {\n          // SHEQ or SHNE\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                  rightTypeRestricted)) {\n            result = n.getType() == Token.SHEQ ?\n                TernaryValue.FALSE : TernaryValue.TRUE;\n          }\n        }\n\n        if (result != TernaryValue.UNKNOWN) {\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        validator.expectObject(t, n, getJSType(n.getLastChild()),\n                               \"'in' requires an object\");\n        left = n.getFirstChild();\n        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, getJSType(left), \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }",
    "comment": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitAssign",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitAssign(NodeTraversal,Node)",
    "snippet": "  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    // Check property sets to 'object.property' when 'object' is known.\n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      checkEnumAlias(t, info, rvalue);\n\n      // Prototype assignments are special, because they actually affect\n      // the definition of a class. These are mostly validated\n      // during TypedScopeCreator, and we only look for the \"dumb\" cases here.\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n            return;\n          }\n        }\n      }\n\n      // The generic checks for 'object.property' when 'object' is known,\n      // and 'property' is declared on it.\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          JSType expectedType = type.getPropertyType(property);\n          if (!expectedType.isUnknownType()) {\n            validator.expectCanAssignToPropertyOf(\n                t, assign, getJSType(rvalue),\n                expectedType, object, property);\n            checkPropertyInheritanceOnGetpropAssign(\n                t, assign, object, property, info, expectedType);\n            return;\n          }\n        }\n      }\n\n      // If we couldn't get the property type with normal object property\n      // lookups, then check inheritance anyway with the unknown type.\n      checkPropertyInheritanceOnGetpropAssign(\n          t, assign, object, property, info, getNativeType(UNKNOWN_TYPE));\n    }\n\n    // Check qualified name sets to 'object' and 'object.property'.\n    // This can sometimes handle cases when the type of 'object' is not known.\n    // e.g.,\n    // var obj = createUnknownType();\n    // /** @type {number} */ obj.foo = true;\n    JSType leftType = getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n            t.getScope() != var.getScope()) {\n          // Don't look at \"this.foo\" variables from other scopes.\n          return;\n        }\n\n        if (var.getType() != null) {\n          leftType = var.getType();\n        }\n      }\n    }\n\n    // Fall through case for arbitrary LHS and arbitrary RHS.\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }",
    "comment": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.isAssign()</code> is an implicit invariant) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitFunction",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitFunction(NodeTraversal,Node)",
    "snippet": "  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          baseConstructor != null &&\n          baseConstructor.isInterface() && functionType.isConstructor()) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                        \"constructor\", functionPrivateName));\n      } else {\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n            baseConstructor != null) {\n          if (functionType.makesStructs() && !baseConstructor.makesStructs()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"struct\", functionPrivateName));\n          } else if (functionType.makesDicts() &&\n                     !baseConstructor.makesDicts()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"dict\", functionPrivateName));\n          }\n        }\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                          \"interface\", functionPrivateName));\n        }\n      }\n      // Interface cannot implement any interfaces\n      if (functionType.hasImplementedInterfaces()) {\n        compiler.report(t.makeError(n,\n            CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n      }\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }",
    "comment": " Visits a {@link Token#FUNCTION} node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitGetProp",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitGetProp(NodeTraversal,Node,Node)",
    "snippet": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (n.getJSType() != null && parent.isAssign()) {\n      return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }",
    "comment": " Visits a GETPROP node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of <code>n</code> ",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitName",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitName(NodeTraversal,Node,Node)",
    "snippet": "  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.PARAM_LIST ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }",
    "comment": " Visits a NAME node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. @return whether the node is typeable or not ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitVar",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitVar(NodeTraversal,Node)",
    "snippet": "  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }",
    "comment": " Visits a VAR node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.TypeInference",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.TypeInference(AbstractCompiler,ControlFlowGraph,ReverseAbstractInterpreter,Scope,Map)",
    "snippet": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.syntacticScope = functionScope;\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (isUnflowable(var)) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.branchedFlowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.branchedFlowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably to expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getIndexType();\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createEntryLattice()",
    "snippet": "  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createInitialEstimateLattice()",
    "snippet": "  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.dereferencePointer",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.dereferencePointer(Node,FlowScope)",
    "snippet": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }",
    "comment": " If we access a property of a symbol, then that symbol is not null or undefined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDeclared",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclared(Node)",
    "snippet": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }",
    "comment": " Defines a declared property if it has not been defined yet.  This handles the case where a property is declared on an object where the object type is inferred, and so the object type will not be known in {@code TypedScopeCreator}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDeclaredHelper",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclaredHelper(Node,ObjectType)",
    "snippet": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }",
    "comment": " Declares a property on its owner, if necessary. @return True if a property was declared. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDefined",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDefined(Node,JSType)",
    "snippet": "  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    JSType nodeType = getJSType(getprop.getFirstChild());\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) ||\n            !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(\n                propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          }\n        } else {\n          if (getprop.getFirstChild().isThis() &&\n              getJSType(syntacticScope.getRootNode()).isConstructor()) {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          } else {\n            registry.registerPropertyOnType(propName, objectType);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Defines a property if the property has not been defined yet. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.flowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.flowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getPropertyType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getPropertyType(JSType,String,Node,FlowScope)",
    "snippet": "  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType unknownType = getNativeType(UNKNOWN_TYPE);\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return getNativeType(UNKNOWN_TYPE);\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.isUnflowable",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.isUnflowable(Var)",
    "snippet": "  private boolean isUnflowable(Var v) {\n    return v != null && v.isLocal() && v.isMarkedEscaped() &&\n        // It's OK to flow a variable in the scope where it's escaped.\n        v.getScope() == syntacticScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.narrowScope",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.narrowScope(FlowScope,Node,JSType)",
    "snippet": "  private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n    if (node.isThis()) {\n      // \"this\" references don't need to be modeled in the control flow graph.\n      return scope;\n    }\n\n    scope = scope.createChildFlowScope();\n    if (node.isGetProp()) {\n      scope.inferQualifiedSlot(\n          node, node.getQualifiedName(), getJSType(node), narrowed);\n    } else {\n      redeclareSimpleVar(scope, node, narrowed);\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.redeclareSimpleVar",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.redeclareSimpleVar(FlowScope,Node,JSType)",
    "snippet": "  private void redeclareSimpleVar(\n      FlowScope scope, Node nameNode, JSType varType) {\n    Preconditions.checkState(nameNode.isName());\n    String varName = nameNode.getString();\n    if (varType == null) {\n      varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (isUnflowable(syntacticScope.getVar(varName))) {\n      return;\n    }\n    scope.inferSlotType(varName, varType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverse",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverse(Node,FlowScope)",
    "snippet": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n    }\n    if (!n.isFunction()) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\n\n        // A stubbed type cast on a qualified name should take\n        // effect for all subsequent accesses of that name,\n        // so treat it the same as an assign to that name.\n        if (n.isQualifiedName() &&\n            n.getParent().isExprResult()) {\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n        }\n\n        n.setJSType(castType);\n      }\n    }\n\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseAssign",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseAssign(Node,FlowScope)",
    "snippet": "  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseChildren",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseChildren(Node,FlowScope)",
    "snippet": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseGetProp",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseGetProp(Node,FlowScope)",
    "snippet": "  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseName",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseName(Node,FlowScope)",
    "snippet": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped and assigned in an inner scope, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable. That variable is assigned more than once,\n        // and we can't know which type we're getting.\n        //\n        // var t = null; function f() { (t); } doStuff(); t = {};\n        //\n        // Notice that this heuristic isn't perfect. For example, you might\n        // have:\n        //\n        // function f() { (t); } f(); var t = 3;\n        //\n        // In this case, we would infer the first reference to t as\n        // type {number}, even though it's undefined.\n        boolean nonLocalInferredSlot = false;\n        if (isInferred && syntacticScope.isLocal()) {\n          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n          if (var == maybeOuterVar &&\n              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n            nonLocalInferredSlot = true;\n          }\n        }\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = getNativeType(UNKNOWN_TYPE);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.updateScopeForTypeChange",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.updateScopeForTypeChange(FlowScope,Node,JSType,JSType)",
    "snippet": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }",
    "comment": " Updates the scope according to the result of a type change, like an assignment or a type cast. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.TypeInferencePass",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.TypeInferencePass(AbstractCompiler,ReverseAbstractInterpreter,Scope,ScopeCreator)",
    "snippet": "  TypeInferencePass(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      Scope topScope, ScopeCreator scopeCreator) {\n    this.compiler = compiler;\n    this.reverseInterpreter = reverseInterpreter;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n\n    assertionFunctionsMap = Maps.newHashMap();\n    for (AssertionFunctionSpec assertionFucntion :\n        compiler.getCodingConvention().getAssertionFunctions()) {\n      assertionFunctionsMap.put(assertionFucntion.getFunctionName(),\n          assertionFucntion);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.computeCfg",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.computeCfg(Node)",
    "snippet": "  private ControlFlowGraph<Node> computeCfg(Node n) {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    return cfa.getCfg();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(Node)",
    "snippet": "  void inferTypes(Node node) {\n    NodeTraversal inferTypes = new NodeTraversal(\n        compiler, new TypeInferringCallback(), scopeCreator);\n    inferTypes.traverseWithScope(node, topScope);\n  }",
    "comment": "Entry point for type inference when running over part of the tree. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(NodeTraversal,Node,Scope)",
    "snippet": "  void inferTypes(NodeTraversal t, Node n, Scope scope) {\n    TypeInference typeInference =\n        new TypeInference(\n            compiler, computeCfg(n), reverseInterpreter, scope,\n            assertionFunctionsMap);\n    try {\n      typeInference.analyze();\n\n      // Resolve any new type names found during the inference.\n      compiler.getTypeRegistry().resolveTypesInScope(scope);\n\n    } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n      compiler.report(t.makeError(n, DATAFLOW_ERROR));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.process",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    inferTypes(externsAndJs);\n  }",
    "comment": " Main entry point for type inference when running over the whole tree.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      inferTypes(t, t.getCurrentNode(), t.getScope());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.visit",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.TypeValidator",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(AbstractCompiler)",
    "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectAllInterfaceProperties",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectAllInterfaceProperties(NodeTraversal,Node,FunctionType)",
    "snippet": "  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }",
    "comment": " Expect that all properties on interfaces that this type implements are implemented and correctly typed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectCanAssignTo",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignTo(NodeTraversal,Node,JSType,JSType,String)",
    "snippet": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if (bothIntrinsics(rightType, leftType)) {\n        // We have a superior warning for this mistake, which gives you\n        // the line numbers of both types.\n        registerMismatch(rightType, leftType, null);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }",
    "comment": " Expect that the first type can be assigned to a symbol of the second type.  @param t The node traversal. @param n The node to issue warnings on. @param rightType The type on the RHS of the assign. @param leftType The type of the symbol on the LHS of the assign. @param msg An extra message for the mismatch warning, if necessary. @return True if the types matched, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectCanAssignToPropertyOf",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignToPropertyOf(NodeTraversal,Node,JSType,JSType,Node,String)",
    "snippet": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if (bothIntrinsics(rightType, leftType)) {\n        // We have a superior warning for this mistake, which gives you\n        // the line numbers of both types.\n        registerMismatch(rightType, leftType, null);\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }",
    "comment": " Expect that the first type can be assigned to a symbol of the second type.  @param t The node traversal. @param n The node to issue warnings on. @param rightType The type on the RHS of the assign. @param leftType The type of the symbol on the LHS of the assign. @param owner The owner of the property being assigned to. @param propName The name of the property being assigned to. @return True if the types matched, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectCanCast",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectCanCast(NodeTraversal,Node,JSType,JSType)",
    "snippet": "  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n    castType = castType.restrictByNotNullOrUndefined();\n    type = type.restrictByNotNullOrUndefined();\n\n    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          castType.toString(), type.toString())));\n    }\n  }",
    "comment": " Expect that the first type can be cast to the second type. The first type should be either a subtype or supertype of the second.  @param t The node traversal. @param n The node where warnings should point. @param type The type being cast from. @param castType The type being cast to. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectNotNullOrUndefined",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectNotNullOrUndefined(NodeTraversal,Node,JSType,String,JSType)",
    "snippet": "  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }",
    "comment": " Expect the type to be anything but the null or void type. If the expectation is not met, issue a warning at the provided node's source code position. Note that a union type that includes the void type and at least one other type meets the expectation. @return Whether the expectation was met. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectUndeclaredVariable",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectUndeclaredVariable(String,CompilerInput,Node,Node,Var,String,JSType)",
    "snippet": "  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type. We should redeclare it at the new input site.\n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }",
    "comment": " Expect that the given variable has not been declared with a type.  @param sourceName The name of the source file we're in. @param n The node where warnings should point to. @param parent The parent of {@code n}. @param var The variable that we're checking. @param variableName The name of the variable. @param newType The type being applied to the variable. Mostly just here for the benefit of the warning. @return The variable we end up with. Most of the time, this will just be {@code var}, but in some rare cases we will need to declare a new var with new source info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.setShouldReport",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.setShouldReport(boolean)",
    "snippet": "  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler,CodingConvention)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.createInitialScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createInitialScope(Node)",
    "snippet": "  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // ActiveXObject is uniquely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }",
    "comment": " Create the outermost scope. This scope contains native binding such as {@code Object}, {@code Date}, etc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Run a first-order analysis over the syntax tree.\n      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n          .process(root.getFirstChild(), root.getLastChild());\n\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type.isFunctionType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes,\n          delegateCallingConventions);\n    }\n    return newScope;\n  }",
    "comment": " Creates a scope with all types declared. Declares newly discovered types and type properties in the type registry. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeFunctionType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeFunctionType(Scope,JSTypeNative)",
    "snippet": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeType(Scope,String,JSType)",
    "snippet": "  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeValueType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeValueType(Scope,String,JSTypeNative)",
    "snippet": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getFunctionAnalysisResults",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getFunctionAnalysisResults(Node)",
    "snippet": "  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n    if (n == null) {\n      return null;\n    }\n\n    // Sometimes this will return null in things like\n    // NameReferenceGraphConstruction that build partial scopes.\n    return functionAnalysisResults.get(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.assertDefinitionNode",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.assertDefinitionNode(Node,int)",
    "snippet": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }",
    "comment": " Asserts that it's OK to define this node's name. The node should have a source name and be of the specified type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.attachLiteralTypes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.attachLiteralTypes(NodeTraversal,Node)",
    "snippet": "    private void attachLiteralTypes(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.createFunctionTypeFromNodes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.createFunctionTypeFromNodes(Node,String,JSDocInfo,Node)",
    "snippet": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() != null &&\n            var.getType().isFunctionType()) {\n          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.isFunction();\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = type.toMaybeFunctionType();\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          Var ownerVar = null;\n          String propName = null;\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = ObjectType.cast(ownerVar.getType());\n            }\n            if (name != null) {\n              propName = name.substring(ownerName.length() + 1);\n            }\n          }\n\n          FunctionType overriddenPropType = null;\n          if (ownerType != null && propName != null) {\n            overriddenPropType =\n                findOverriddenFunction(ownerType, propName);\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setContents(getFunctionAnalysisResults(fnRoot))\n              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (ownerType != null && ownerType.isFunctionPrototypeType() &&\n              ownerType.getOwnerFunction().hasInstanceType()) {\n            builder.inferThisType(\n                info, ownerType.getOwnerFunction().getInstanceType());\n            searchedForThisType = true;\n          } else if (ownerNode != null && ownerNode.isThis()) {\n            // If 'this' has a type, use that instead.\n            // This is a hack, necessary because CollectProperties (below)\n            // doesn't run with the scope that it's building,\n            // so scope.getTypeOfThis() will be wrong.\n            JSType injectedThisType = ownerNode.getJSType();\n            builder.inferThisType(\n                info,\n                injectedThisType == null ?\n                scope.getTypeOfThis() : injectedThisType);\n            searchedForThisType = true;\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }",
    "comment": " Creates a new function type, based on the given nodes.  This handles two cases that are semantically very different, but are not mutually exclusive: - A function literal that needs a type attached to it. - An assignment expression with function-type info in the JsDoc.  All parameters are optional, and we will do the best we can to create a function type.  This function will always create a function type, so only call it if you're sure that's what you want.  @param rValue The function node. @param name the function's name @param info the {@link JSDocInfo} attached to the function definition @param lvalueNode The node where this function is being assigned. For example, {@code A.prototype.foo = ...} would be used to determine that this function is a method of A.prototype. May be null to indicate that this is not being assigned to a qualified name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineFunctionLiteral",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineFunctionLiteral(Node,Node)",
    "snippet": "    void defineFunctionLiteral(Node n, Node parent) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and l-value for the function.\n      // Any of these may be null.\n      Node lValue = NodeUtil.getBestLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      String functionName = NodeUtil.getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }",
    "comment": " Defines a function literal. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineName(Node,Node,Node,JSDocInfo)",
    "snippet": "    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(sourceName, info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        type = name.isFromExterns() ?\n            getNativeType(UNKNOWN_TYPE) : null;\n      }\n      defineSlot(name, var, type);\n    }",
    "comment": " Defines a variable based on the {@link Token#NAME} node passed. @param name The {@link Token#NAME} node. @param var The parent of the {@code name} node, which must be a {@link Token#VAR} node. @param parent {@code var}'s parent. @param info the {@link JSDocInfo} information relating to this {@code name} node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType)",
    "snippet": "    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type or {@code null} if its type is inferred. @param name the defining node. It must be a {@link Token#NAME}. @param parent the {@code name}'s parent. @param type the variable's type. It may be {@code null}, in which case the variable's type will be inferred. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType,boolean)",
    "snippet": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() ||\n            parent.isCatch());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() &&\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is inferred.  Slots may be any variable or any qualified name in the global scope.  @param n the defining NAME or GETPROP node. @param parent the {@code n}'s parent. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,String,JSType,boolean)",
    "snippet": "    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.isName() && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.isVar() ||\n           parent.isFunction());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.isGetProp() && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // The input may be null if we are working with a AST snippet. So read\n      // the extern info from the node.\n      boolean isExtern = n.isFromExterns();\n      Var newVar = null;\n\n      // declared in closest scope?\n      CompilerInput input = compiler.getInput(inputId);\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        newVar = validator.expectUndeclaredVariable(\n            sourceName, input, n, parent, oldVar, variableName, type);\n      } else {\n        if (type != null) {\n          setDeferredType(n, type);\n        }\n\n        newVar =\n          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.isObjectLit() ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n      }\n\n      // We need to do some additional work for constructors and interfaces.\n      FunctionType fnType = JSType.toMaybeFunctionType(type);\n      if (fnType != null &&\n          // We don't want to look at empty function types.\n          !type.isEmptyType()) {\n        if ((fnType.isConstructor() || fnType.isInterface()) &&\n            !fnType.isEquivalentTo(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n          // Declare var.prototype in the scope chain.\n          FunctionType superClassCtor = fnType.getSuperClassConstructor();\n          ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n          // When we declare the function prototype implicitly, we\n          // want to make sure that the function and its prototype\n          // are declared at the same node. We also want to make sure\n          // that the if a symbol has both a Var and a JSType, they have\n          // the same node.\n          //\n          // This consistency is helpful to users of SymbolTable,\n          // because everything gets declared at the same place.\n          prototypeSlot.setNode(n);\n\n          String prototypeName = variableName + \".prototype\";\n\n          // There are some rare cases where the prototype will already\n          // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n          // Fortunately, other warnings will complain if this happens.\n          Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n          if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n            scopeToDeclareIn.undeclare(prototypeVar);\n          }\n\n          scopeToDeclareIn.declare(prototypeName,\n              n, prototypeSlot.getType(), input,\n              /* declared iff there's an explicit supertype */\n              superClassCtor == null ||\n              superClassCtor.getInstanceType().isEquivalentTo(\n                  getNativeType(OBJECT_TYPE)));\n\n          // Make sure the variable is initialized to something if\n          // it constructs itself.\n          if (newVar.getInitialValue() == null &&\n              !isExtern &&\n              // We want to make sure that when we declare a new instance\n              // type (with @constructor) that there's actually a ctor for it.\n              // This doesn't apply to structural constructors\n              // (like function(new:Array). Checking the constructed\n              // type against the variable name is a sufficient check for\n              // this.\n              variableName.equals(\n                  fnType.getInstanceType().getReferenceName())) {\n            compiler.report(\n                JSError.make(sourceName, n,\n                    fnType.isConstructor() ?\n                    CTOR_INITIALIZER : IFACE_INITIALIZER,\n                    variableName));\n          }\n        }\n      }\n\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS);\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n              getNativeType(JSTypeNative.NO_TYPE) :\n              type,\n              n);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, n);\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type != null\n          && type.isFunctionType()\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n      }\n    }",
    "comment": " Defines a symbol in the current scope.  @param n the defining NAME or GETPROP or object literal key node. @param parent the {@code n}'s parent. @param variableName The name that this should be known by. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. @param inferred Whether the type is inferred or declared. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineVar",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineVar(Node,Node)",
    "snippet": "    void defineVar(Node n, Node parent) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, parent, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, parent,\n            (info != null) ? info : name.getJSDocInfo());\n      }\n    }",
    "comment": " Defines a VAR initialization. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.findOverriddenFunction",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.findOverriddenFunction(ObjectType,String)",
    "snippet": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType != null && propType.isFunctionType()) {\n        return propType.toMaybeFunctionType();\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType != null && propType.isFunctionType()) {\n            return propType.toMaybeFunctionType();\n          }\n        }\n      }\n\n      return null;\n    }",
    "comment": " Find the function that's being overridden on this type, if any. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredType(String,JSDocInfo,Node,Node)",
    "snippet": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "comment": " Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).  @param info The doc info for this property. @param lValue The l-value node. @param rValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredTypeInAnnotation",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredTypeInAnnotation(String,Node,JSDocInfo)",
    "snippet": "    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode =\n          node.isGetProp() ? node.getFirstChild() :\n          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n          null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }",
    "comment": " Returns the type specified in a JSDoc annotation near a GETPROP or NAME.  Extracts type information from either the {@code @type} tag or from the {@code @return} and {@code @param} tags. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getObjectSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getObjectSlot(String)",
    "snippet": "    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }",
    "comment": " Find the ObjectType associated with the given slot. @param slotName The name of the slot to find the type in. @return An object type, or null if this slot does not contain an object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.isQualifiedNameInferred",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.isQualifiedNameInferred(String,Node,JSDocInfo,Node,JSType)",
    "snippet": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "comment": " Determines whether a qualified name is inferred. NOTE(nicksantos): Determining whether a property is declared or not is really really obnoxious.  The problem is that there are two (equally valid) coding styles:  (function() { The authoritative definition of goog.bar. / goog.bar = function() {}; })();  function f() { goog.bar(); Reset goog.bar to a no-op. / goog.bar = function() {}; }  In a dynamic language with first-class functions, it's very difficult to know which one the user intended without looking at lots of contextual information (the second example demonstrates a small case of this, but there are some really pathological cases as well).  The current algorithm checks if either the declaration has JsDoc type information, or @const with a known type, or a function literal with a name we haven't seen before. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.maybeDeclareQualifiedName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
    "snippet": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }",
    "comment": " Declare the symbol for a qualified name in the global scope.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param parent The parent of {@code n}. @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.resolveStubDeclarations",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveStubDeclarations()",
    "snippet": "    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }",
    "comment": " Resolve any stub declarations to unknown types if we could not find types for them during traversal. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.resolveTypes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveTypes()",
    "snippet": "    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.setDeferredType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.setDeferredType(Node,JSType)",
    "snippet": "    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      if (n.isFunction() ||\n          n.isScript()) {\n        Preconditions.checkNotNull(inputId);\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child, n);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.shouldUseFunctionLiteralType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.shouldUseFunctionLiteralType(FunctionType,JSDocInfo,Node)",
    "snippet": "    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }",
    "comment": " If a variable is assigned a function literal in the global scope, make that a declared type (even if there's no doc info). There's only one exception to this rule: if the return type is inferred, and we're in a local scope, we should assume the whole function is inferred. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      attachLiteralTypes(t, n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n, parent);\n          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // Hoisted functions are handled during pre-traversal.\n          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n            defineFunctionLiteral(n, parent);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.isGetProp() &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.isExprResult() &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n\n      // Analyze any @lends object literals in this statement.\n      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n          lentObjectLiterals != null) {\n        for (Node objLit : lentObjectLiterals) {\n          defineObjectLiteral(objLit);\n        }\n        lentObjectLiterals.clear();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CollectProperties.maybeCollectMember",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder$CollectProperties",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder$CollectProperties.maybeCollectMember(NodeTraversal,Node,Node,Node)",
    "snippet": "      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n\n        // Do nothing if there is no JSDoc type info, or\n        // if the node is not a member expression, or\n        // if the member expression is not of the form: this.someProperty.\n        if (info == null ||\n            !member.isGetProp() ||\n            !member.getFirstChild().isThis()) {\n          return;\n        }\n\n        member.getFirstChild().setJSType(thisType);\n        JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);\n        Node name = member.getLastChild();\n        if (jsType != null &&\n            (name.isName() || name.isString())) {\n          thisType.defineDeclaredProperty(\n              name.getString(),\n              jsType,\n              member);\n        }\n      }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CollectProperties.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder$CollectProperties",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder$CollectProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isExprResult()) {\n          Node child = n.getFirstChild();\n          switch (child.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(t, child.getFirstChild(), child,\n                  child.getLastChild());\n              break;\n            case Token.GETPROP:\n              maybeCollectMember(t, child, child, null);\n              break;\n          }\n        }\n      }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DeferredSetType.resolve",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType.resolve(Scope)",
    "snippet": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiscoverEnumsAndTypedefs.identifyNameNode",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs.identifyNameNode(Node,Node,JSDocInfo)",
    "snippet": "    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiscoverEnumsAndTypedefs.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      Node nameNode = null;\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, child.getFirstChild(),\n                NodeUtil.getBestJSDocInfo(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.isAssign()) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getLastChild(),\n                firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, null, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FirstOrderFunctionAnalyzer.enterScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer.enterScope(NodeTraversal)",
    "snippet": "    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FirstOrderFunctionAnalyzer.process",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer.process(Node,Node)",
    "snippet": "    @Override public void process(Node externs, Node root) {\n      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FirstOrderFunctionAnalyzer.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.checkForTypedef",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.checkForTypedef(NodeTraversal,Node,JSDocInfo)",
    "snippet": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recursive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.isGetProp()) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }",
    "comment": " Handle typedefs. @param t The current traversal. @param candidate A qualified name node. @param info JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.maybeDeclareQualifiedName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
    "snippet": "    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }",
    "comment": " Visit a node in the global scope, and add anything it declares to the global symbol table.  @param t The current traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.build",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.build()",
    "snippet": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents != null) {\n        for (String varName : contents.getEscapedVarNames()) {\n          Var v = scope.getVar(varName);\n          Preconditions.checkState(v.getScope() == scope);\n          v.markEscaped();\n        }\n\n        for (Multiset.Entry<String> entry :\n                 contents.getAssignedNameCounts().entrySet()) {\n          Var v = scope.getVar(entry.getElement());\n          Preconditions.checkState(v.getScope() == scope);\n          if (entry.getCount() == 1) {\n            v.markAssignedExactlyOnce();\n          }\n        }\n      }\n    }",
    "comment": " Traverse the scope root and build it. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.declareArguments",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.declareArguments(Node)",
    "snippet": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      boolean isFnTypeInferred = functionNode.getBooleanProp(\n          Node.INFERRED_FUNCTION);\n      FunctionType functionType =\n          JSType.toMaybeFunctionType(functionNode.getJSType());\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), isFnTypeInferred);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments",
    "comment": " Declares all of a function's arguments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.handleFunctionInputs",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.handleFunctionInputs(Node)",
    "snippet": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }",
    "comment": "Handle bleeding functions and function parameters. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.isParamList() && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }",
    "comment": " Visit a node in a local scope, and add any local variables or catch parameters into the local symbol table.  @param t The node traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  protected boolean disables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether all warnings in the given diagnostic group will be filtered out. Used to determine which passes to skip.  @param group A group of DiagnosticTypes. @return Whether all warnings of these types are disabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  protected boolean enables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether any of the warnings in the given diagnostic group will be upgraded to a warning or error.  @param group A group of DiagnosticTypes. @return Whether any warnings of these types are enabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DiGraph.isConnected",
    "class_name": "com.google.javascript.jscomp.graph.DiGraph",
    "signature": "com.google.javascript.jscomp.graph.DiGraph.isConnected(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnected(N n1, E e, N n2) {\n    return isConnectedInDirection(n1, e, n2) ||\n        isConnectedInDirection(n2, e, n1);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Graph.connectIfNotFound",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N,E,N)",
    "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    if (!isConnected(n1, edge, n2)) {\n      connect(n1, edge, n2);\n    }\n  }",
    "comment": " Connects two nodes in the graph with an edge if such edge does not already exists between the nodes.  @param n1 First node. @param edge The edge. @param n2 Second node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Graph.getNodeOrFail",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.getNodeOrFail(N)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n    T node = (T) getNode(val);\n    if (node == null) {\n      throw new IllegalArgumentException(val + \" does not exist in graph\");\n    }\n    return node;\n  }",
    "comment": " Gets the node of the specified type, or throws an IllegalArgumentException. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.LinkedDirectedGraph",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraph(boolean,boolean)",
    "snippet": "  protected LinkedDirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.connect",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N,E,N)",
    "snippet": "  @Override\n  public void connect(N srcValue, E edgeValue, N destValue) {\n    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n    LinkedDirectedGraphEdge<N, E> edge =\n        useEdgeAnnotations ?\n        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = useNodeAnnotations ?\n          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n          new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
    "snippet": "  @Override\n  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n        nodes.values());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedPredNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedPredNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedPredNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getInEdges()) {\n      nodeList.add(edge.getSource());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedSuccNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getOutEdges(N)",
    "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,Predicate,N)",
    "snippet": "  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n    // Verify the nodes.\n    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2 &&\n          edgeMatcher.apply(outEdge.getValue())) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.getAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.getAnnotation()",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.setAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.setAnnotation(Annotation)",
    "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getDestination",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getDestination()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getSource",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getSource()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getSource() {\n      return sourceNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getValue()",
    "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getInEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getInEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getOutEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getValue()",
    "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,LanguageMode,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createJsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createJsDocInfoParser(Comment,Node)",
    "snippet": "  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }",
    "comment": " Creates a JsDocInfoParser and parses the JsDoc string.  Used both for handling individual JSDoc comments and for handling file-level JSDoc comments (@fileoverview and @license).  @param node The JsDoc Comment node to parse. @param irNode @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or normal JsDoc, or no JsDoc (if the method parses to the wrong level). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode,Node)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.handlePossibleFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handlePossibleFileOverviewJsDoc(JsDocInfoParser)",
    "snippet": "  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }",
    "comment": " @return true if the jsDocParser represents a fileoverview. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.maybeSetLengthFrom",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(Node,AstNode)",
    "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }",
    "comment": "Set the length on the node if we're in IDE mode.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node,Node)",
    "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNumberNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(Double)",
    "snippet": "  private Node newNumberNode(Double value) {\n    return IR.number(value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int,String)",
    "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo();\n    if (rootNodeJsDoc != null) {\n      irNode.setJSDocInfo(rootNodeJsDoc);\n      rootNodeJsDoc.setAssociatedNode(irNode);\n    }\n\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n      fileOverviewInfo.setAssociatedNode(irNode);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setSourceInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(Node,AstNode)",
    "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    if (irNode.getLineno() == -1) {\n      // If we didn't already set the line, then set it now. This avoids\n      // cases like ParenthesizedExpression where we just return a previous\n      // node, but don't want the new node to get its parent's line number.\n      int lineno = node.getLineno();\n      irNode.setLineno(lineno);\n      int charno = position2charno(node.getAbsolutePosition());\n      irNode.setCharno(charno);\n      maybeSetLengthFrom(irNode, node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformNameAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformNameAsString(Name)",
    "snippet": "  private Node transformNameAsString(Name node) {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.rhino.head.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.rhino.head.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.rhino.head.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.rhino.head.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.rhino.head.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.rhino.head.Token.NE:\n        return Token.NE;\n      case com.google.javascript.rhino.head.Token.LT:\n        return Token.LT;\n      case com.google.javascript.rhino.head.Token.LE:\n        return Token.LE;\n      case com.google.javascript.rhino.head.Token.GT:\n        return Token.GT;\n      case com.google.javascript.rhino.head.Token.GE:\n        return Token.GE;\n      case com.google.javascript.rhino.head.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.rhino.head.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.rhino.head.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.rhino.head.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.rhino.head.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.rhino.head.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.rhino.head.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.rhino.head.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.rhino.head.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.rhino.head.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.rhino.head.Token.POS:\n        return Token.POS;\n      case com.google.javascript.rhino.head.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.rhino.head.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.rhino.head.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.rhino.head.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.rhino.head.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.rhino.head.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.rhino.head.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.rhino.head.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.rhino.head.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.rhino.head.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.rhino.head.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.rhino.head.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.rhino.head.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.rhino.head.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.rhino.head.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.rhino.head.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.rhino.head.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.rhino.head.Token.IN:\n        return Token.IN;\n      case com.google.javascript.rhino.head.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.rhino.head.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.rhino.head.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.rhino.head.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.rhino.head.Token.LP:\n        return Token.PARAM_LIST;\n      case com.google.javascript.rhino.head.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.rhino.head.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.rhino.head.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.rhino.head.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.rhino.head.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.rhino.head.Token.OR:\n        return Token.OR;\n      case com.google.javascript.rhino.head.Token.AND:\n        return Token.AND;\n      case com.google.javascript.rhino.head.Token.INC:\n        return Token.INC;\n      case com.google.javascript.rhino.head.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.rhino.head.Token.IF:\n        return Token.IF;\n      case com.google.javascript.rhino.head.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.rhino.head.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.rhino.head.Token.DEFAULT:\n        return Token.DEFAULT_CASE;\n      case com.google.javascript.rhino.head.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.rhino.head.Token.DO:\n        return Token.DO;\n      case com.google.javascript.rhino.head.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.rhino.head.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.rhino.head.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.rhino.head.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.rhino.head.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.rhino.head.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.rhino.head.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.rhino.head.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.rhino.head.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.rhino.head.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.rhino.head.Token.EXPR_VOID:\n      case com.google.javascript.rhino.head.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.rhino.head.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.rhino.head.Token.GET:\n        return Token.GETTER_DEF;\n      case com.google.javascript.rhino.head.Token.SET:\n        return Token.SETTER_DEF;\n      case com.google.javascript.rhino.head.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.rhino.head.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,StaticSourceFile,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isReservedKeyword",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isReservedKeyword(String)",
    "snippet": "    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }",
    "comment": " @return Whether the ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of ECMA-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAssignment",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAssignment(Assignment)",
    "snippet": "    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n      return assign;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.rhino.head.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        Node paramNode = transform(param);\n        // When in ideMode Rhino can generate a param list with only a single\n        // ErrorNode. This is transformed into an EMPTY node. Drop this node in\n        // ideMode to keep the AST in a valid state.\n        if (paramNode.isName()) {\n          lp.addChildToBack(paramNode);\n        } else {\n          // We expect this in ideMode or when there is an error handling\n          // destructuring parameter assignments which aren't supported\n          // (an error has already been reported).\n          Preconditions.checkState(\n              config.isIdeMode\n              || paramNode.isObjectLit()\n              || paramNode.isArrayLit());\n        }\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.rhino.head.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.rhino.head.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processInfixExpression",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processInfixExpression(InfixExpression)",
    "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      n.setLineno(exprNode.getLineno());\n      n.setCharno(position2charno(exprNode.getAbsolutePosition()));\n      maybeSetLengthFrom(n, exprNode);\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processKeywordLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processKeywordLiteral(KeywordLiteral)",
    "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name,boolean)",
    "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processNumberLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processNumberLiteral(NumberLiteral)",
    "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processPropertyGet",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processPropertyGet(PropertyGet)",
    "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      Node leftChild = transform(getNode.getTarget());\n      Node newNode = newNode(\n          Token.GETPROP, leftChild, transformAsString(getNode.getProperty()));\n      newNode.setLineno(leftChild.getLineno());\n      newNode.setCharno(leftChild.getCharno());\n      maybeSetLengthFrom(newNode, getNode);\n      return newNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableDeclaration",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableDeclaration(VariableDeclaration)",
    "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.rhino.head.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableInitializer",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableInitializer(VariableInitializer)",
    "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        Node initalizer = transform(initializerNode.getInitializer());\n        node.addChildToBack(initalizer);\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.transformAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.transformAsString(AstNode)",
    "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name)n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral)n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.isString());\n      return ret;\n    }",
    "comment": " Transforms the given node and then sets its type to Token.STRING if it was Token.NAME. If its type was already Token.STRING, then quotes it. Used for properties, as the old AST uses String tokens, while the new one uses Name tokens for unquoted strings. For example, in var o = {'a' : 1, b: 2}; the string 'a' is quoted, while the name b is turned into a string, but unquoted. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.validAssignmentTarget",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.validAssignmentTarget(Node)",
    "snippet": "    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.JsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(JsDocTokenStream,Comment,Node,Config,ErrorReporter)",
    "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.associatedNode = associatedNode;\n\n    // Sometimes this will be null in tests.\n    this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();\n\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    if (commentNode != null) {\n      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n    }\n    this.annotationNames = config.annotationNames;\n    this.suppressionNames = config.suppressionNames;\n\n    this.errorReporter = errorReporter;\n    this.templateNode = this.createTemplateNode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.checkExtendedTypes",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.checkExtendedTypes(List)",
    "snippet": "  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      // If interface, record the multiple extended interfaces\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.createJSTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(Node)",
    "snippet": "  private JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, getSourceName());\n  }",
    "comment": " Constructs a new {@code JSTypeExpression}. @param n A node. May be null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = IR.script();\n    templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);\n    return templateNode;\n  }",
    "comment": "e.g., source-name, between all nodes.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.current",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
    "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }",
    "comment": " Gets the current token, invalidating it in the process. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
    "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(JsDocToken)",
    "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.getFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
    "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }",
    "comment": " Gets the fileoverview JSDocInfo, if any. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.getSourceName",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getSourceName()",
    "snippet": "  private String getSourceName() {\n    return sourceFile == null ? null : sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
    "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }",
    "comment": " Determines whether the parser has been populated with docinfo with a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.lookAheadForTypeAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.lookAheadForTypeAnnotation()",
    "snippet": "  private boolean lookAheadForTypeAnnotation() {\n    boolean matchedLc = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == '{') {\n        matchedLc = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matchedLc;\n  }",
    "comment": " Look ahead for a type annotation by advancing the character stream. Does not modify the token stream. This is kind of a hack, and is only necessary because we use the token stream to parse types, but need the underlying character stream to get JsDoc descriptions. @return Whether we found a type annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.match",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(JsDocToken)",
    "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }",
    "comment": " Tests whether the next symbol of the token stream matches the specific token. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(String,int,int)",
    "snippet": "  private Node newStringNode(String s, int lineno, int charno) {\n    Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n    n.setLength(s.length());\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.next",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
    "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }",
    "comment": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parse",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
    "snippet": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
    "comment": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordParamTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    if (typeNode != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n\n      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);\n    }\n    return typeNode;\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param matchingLC Whether the type expression starts with a \"{\". @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,int,int,boolean,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    if (typeNode != null && !matchingLC) {\n      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n    }\n\n    if (typeNode != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n\n      jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);\n    }\n\n    return typeNode;\n  }",
    "comment": " Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @param matchingLC Whether the type expression starts with a \"{\". @param onlyParseSimpleNames If true, only simple type names are parsed (via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation). @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseBasicTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(JsDocToken)",
    "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }",
    "comment": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }",
    "comment": " ParamTypeExpressionAnnotation := '{' OptionalParameterType '}' | '{' TopLevelTypeExpression '}' | '{' '...' TopLevelTypeExpression '}'  OptionalParameterType := TopLevelTypeExpression '=' ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTopLevelTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }",
    "comment": " TopLevelTypeExpression := TypeExpression | TypeUnionList  We made this rule up, for the sake of backwards compatibility. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 5 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }",
    "comment": " TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?' ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }",
    "comment": " TypeExpressionAnnotation := TypeExpression | '{' TopLevelTypeExpression '}' ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeName",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(JsDocToken)",
    "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }",
    "comment": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
    "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(associatedNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileLevelJsDocBuilder",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(FileLevelJsDocBuilder)",
    "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }",
    "comment": " Sets the JsDocBuilder for the file-level (root) node of this parse. The parser uses the builder to append any preserve annotations it encounters in JsDoc comments.  @param fileLevelJsDocBuilder ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(JSDocInfo)",
    "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }",
    "comment": " Sets the file overview JSDocInfo, in order to warn about multiple uses of the @fileoverview tag in a file. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.skipEOLs",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
    "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }",
    "comment": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.wrapNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int,Node)",
    "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.JsDocTokenStream",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(String,int,int)",
    "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.addToString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
    "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
    "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
    "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
    "snippet": "  final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getJsDocToken",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a JsDoc string but discard last . if it is followed by\n          // a non-JsDoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Tokenizes JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getLineno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
    "snippet": "  final int getLineno() { return lineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getOffset",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
    "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }",
    "comment": " Returns the offset into the current line. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
    "snippet": "  final String getString() { return string; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getStringFromBuffer",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
    "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isAlpha",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
    "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSDocString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
    "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSSpace",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
    "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }",
    "comment": "As defined in ECMA.  jsscan.c uses C isspace() (which allows \\v, I think.)  note that code in getChar() implicitly accepts '\\r' == \\u000D as well. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.matchChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
    "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
    "snippet": "  void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetCharIgnoreLineEnd(int)",
    "snippet": "  private void ungetCharIgnoreLineEnd(int c) {\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,LanguageMode,boolean,Set)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(StaticSourceFile,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(StaticSourceFile sourceFile,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    // Do our own identifier check for ECMASCRIPT 5\n    boolean acceptEs5 =\n        config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;\n    compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return (node instanceof EmptyExpression) ?\n            processEmptyExpression((EmptyExpression) node) :\n            processEmptyStatement((EmptyStatement) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  public ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }",
    "comment": " Constructs an interpreter, which is the only link in a chain. Interpreters can be appended using {@link #append}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  public SemanticReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n  }",
    "comment": " Creates a semantic reverse abstract interpreter. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IR.number",
    "class_name": "com.google.javascript.rhino.IR",
    "signature": "com.google.javascript.rhino.IR.number(double)",
    "snippet": "  public static Node number(double d) {\n    return Node.newNumber(d);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IR.script",
    "class_name": "com.google.javascript.rhino.IR",
    "signature": "com.google.javascript.rhino.IR.script()",
    "snippet": "  public static Node script() {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    return block;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InputId.InputId",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.InputId(String)",
    "snippet": "  public InputId(String id) {\n    this.id = id;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InputId.equals",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass() != obj.getClass()) return false;\n    return id.equals(((InputId) obj).id);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InputId.getIdName",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.getIdName()",
    "snippet": "  public String getIdName() {\n    return id;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InputId.hashCode",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.addMarker",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
    "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }",
    "comment": " Adds a marker to the documentation (if it exists) and returns the marker. Returns null otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.declareParam",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(JSTypeExpression,String)",
    "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Declares a parameter. Parameters are described using the {@code @param} annotation.  @param jsType the parameter's type, it may be {@code null} when the {@code @param} annotation did not specify a type. @param parameter the parameter's name ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
    "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }",
    "comment": " Gets the base type specified by the {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getExtendedInterfacesCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getExtendedInterfacesCount()",
    "snippet": "  public int getExtendedInterfacesCount() {\n    if (info == null || info.extendedInterfaces == null) {\n      return 0;\n    }\n    return info.extendedInterfaces.size();\n  }",
    "comment": " Gets the number of extended interfaces specified ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
    "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getImplementedInterfaceCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaceCount()",
    "snippet": "  public int getImplementedInterfaceCount() {\n    if (info == null || info.implementedInterfaces == null) {\n      return 0;\n    }\n    return info.implementedInterfaces.size();\n  }",
    "comment": " Gets the number of interfaces specified by the {@code @implements} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaces()",
    "snippet": "  public List<JSTypeExpression> getImplementedInterfaces() {\n    if (info == null || info.implementedInterfaces == null) {\n      return ImmutableList.of();\n    }\n    return Collections.unmodifiableList(info.implementedInterfaces);\n  }",
    "comment": " Returns the types specified by the {@code @implements} annotation.  @return An immutable list of JSTypeExpression objects that can be resolved to types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getLendsName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getLendsName()",
    "snippet": "  public String getLendsName() {\n    return (info == null) ? null : info.lendsName;\n  }",
    "comment": " Gets the name we're lending to in a {@code @lends} annotation.  In many reflection APIs, you pass an anonymous object to a function, and that function mixes the anonymous object into another object. The {@code @lends} annotation allows the type system to track those property assignments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
    "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }",
    "comment": " Gets the number of parameters defined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterNames",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterNames()",
    "snippet": "  public Set<String> getParameterNames() {\n    if (info == null || info.parameters == null) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(info.parameters.keySet());\n  }",
    "comment": " Returns the set of names of the defined parameters. The iteration order of the returned set is not the order in which parameters are defined.  @return the set of names of the defined parameters. The returned set is immutable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(String)",
    "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }",
    "comment": " Gets the parameter type. @param parameter the parameter's name @return the parameter's type or {@code null} if this parameter is not defined or has a {@code null} type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getReturnType()",
    "snippet": "  public JSTypeExpression getReturnType() {\n    return getType(TYPEFIELD_RETURN);\n  }",
    "comment": " Gets the return type specified by the {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getTemplateTypeNames",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getTemplateTypeNames()",
    "snippet": "  public ImmutableList<String> getTemplateTypeNames() {\n    if (info == null || info.templateTypeNames == null) {\n      return ImmutableList.of();\n    }\n    return info.templateTypeNames;\n  }",
    "comment": "Gets the template type name. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getType()",
    "snippet": "  public JSTypeExpression getType() {\n    return getType(TYPEFIELD_TYPE);\n  }",
    "comment": " Gets the type specified by the {@code @type} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getType(int)",
    "snippet": "  private JSTypeExpression getType(int typefield) {\n    if ((MASK_TYPEFIELD & bitset) == typefield) {\n      return type;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
    "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }",
    "comment": " Gets the visibility specified by {@code @private}, {@code @protected} or {@code @public} annotation. If no visibility is specified, visibility is inherited from the base class. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
    "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasEnumParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
    "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }",
    "comment": " Returns whether an enum parameter type, specified using the {@code @enum} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
    "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }",
    "comment": " Returns whether this has a fileoverview flag. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasParameterType(String)",
    "snippet": "  public boolean hasParameterType(String parameter) {\n    return getParameterType(parameter) != null;\n  }",
    "comment": " Returns whether the parameter has an attached type.  @return {@code true} if the parameter has an attached type, {@code false} if the parameter has no attached type or does not exist. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
    "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
    "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
    "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }",
    "comment": " Returns whether a type, specified using the {@code @type} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
    "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasTypedefType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
    "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }",
    "comment": " Returns whether a typedef parameter type, specified using the {@code @typedef} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstant",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstant()",
    "snippet": "  public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }",
    "comment": " Returns whether the {@code @const} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }",
    "comment": " Returns whether the {@code @constructor} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isDefine",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
    "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }",
    "comment": " Returns whether the {@code @define} annotation is present on this {@link JSDocInfo}. If this annotation is present, then the {@link #getType()} method will retrieve the define type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isExterns",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
    "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }",
    "comment": " Returns whether the {@code @externs} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isImplicitCast",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isImplicitCast()",
    "snippet": "  public boolean isImplicitCast() {\n    return getFlag(MASK_IMPLICITCAST);\n  }",
    "comment": " Returns whether the {@code @implicitCast} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isInterface",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }",
    "comment": " Returns whether the {@code @interface} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isJavaDispatch",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
    "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }",
    "comment": " Returns whether the {@code @javadispatch} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoCompile",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoCompile()",
    "snippet": "  public boolean isNoCompile() {\n    return getFlag(MASK_NOCOMPILE);\n  }",
    "comment": " Returns whether the {@code @nocompile} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoTypeCheck",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoTypeCheck()",
    "snippet": "  public boolean isNoTypeCheck() {\n    return getFlag(MASK_NOCHECK);\n  }",
    "comment": " Returns whether the {@code @nocheck} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isOverride",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isOverride()",
    "snippet": "  public boolean isOverride() {\n    return getFlag(MASK_OVERRIDE);\n  }",
    "comment": " Returns whether the {@code @override} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
    "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }",
    "comment": " Lazily initializes the documentation information object, but only if the JSDocInfo was told to keep such information around. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
    "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.makesDicts",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.makesDicts()",
    "snippet": "  public boolean makesDicts() {\n    return getFlag(MASK_DICT);\n  }",
    "comment": " Returns whether the {@code @dict} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.makesStructs",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.makesStructs()",
    "snippet": "  public boolean makesStructs() {\n    return getFlag(MASK_STRUCT);\n  }",
    "comment": " Returns whether the {@code @struct} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setAssociatedNode",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setAssociatedNode(Node)",
    "snippet": "  public void setAssociatedNode(Node node) {\n    this.associatedNode = node;\n  }",
    "comment": " Sets the node associated with this JSDoc. Notice that many nodes may have pointer to the same JSDocInfo object (because we propagate it across the type graph). But there is only one canonical \"owner\" node of the JSDocInfo, which corresponds to its original place in the syntax tree. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
    "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean,int)",
    "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setReturnType(JSTypeExpression)",
    "snippet": "  void setReturnType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_RETURN);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression)",
    "snippet": "  void setType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression,int)",
    "snippet": "  private void setType(JSTypeExpression type, int mask) {\n    if ((bitset & MASK_TYPEFIELD) != 0) {\n      throw new IllegalStateException(\n          \"API tried to add two incompatible type tags. \" +\n          \"This should have been blocked and emitted a warning.\");\n    }\n    this.bitset = (bitset & MASK_FLAGS) | mask;\n    this.type = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(Visibility)",
    "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }",
    "comment": "Visible for testing.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.JSDocInfoBuilder",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
    "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.build",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(Node)",
    "snippet": "  public JSDocInfo build(Node associatedNode) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setAssociatedNode(associatedNode);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }",
    "comment": " Builds a {@link JSDocInfo} object based on the populated information and returns it. Once this method is called, the builder can be reused to build another {@link JSDocInfo} object.  @param associatedNode The source node containing the JSDoc. @return a {@link JSDocInfo} object populated with the values given to this builder. If no value was populated, this method simply returns {@code null} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnySingletonTypeTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
    "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }",
    "comment": " Whether the current doc info has any of the singleton type tags that may not appear with other type tags, like {@code @type} or {@code @typedef}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnyTypeRelatedTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnyTypeRelatedTags()",
    "snippet": "  private boolean hasAnyTypeRelatedTags() {\n    return currentInfo.isConstructor() ||\n        currentInfo.isInterface() ||\n        currentInfo.getParameterCount() > 0 ||\n        currentInfo.hasReturnType() ||\n        currentInfo.hasBaseType() ||\n        currentInfo.getExtendedInterfacesCount() > 0 ||\n        currentInfo.getLendsName() != null ||\n        currentInfo.hasThisType() ||\n        hasAnySingletonTypeTags();\n  }",
    "comment": " Whether the current doc info has other type tags, like {@code @param} or {@code @return} or {@code @type} or etc. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulated",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
    "snippet": "  public boolean isPopulated() {\n    return populated;\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulatedWithFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
    "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns() ||\n         currentInfo.isNoCompile());\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object that has a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markAnnotation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(String,int,int)",
    "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(annotation);\n      position.setPositionInformation(lineno, charno, lineno,\n          charno + annotation.length());\n      marker.setAnnotation(position);\n      populated = true;\n    }\n\n    currentMarker = marker;\n  }",
    "comment": " Adds a marker to the current JSDocInfo and populates the marker with the annotation information. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markName",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(String,StaticSourceFile,int,int)",
    "snippet": "  public void markName(String name, StaticSourceFile file,\n      int lineno, int charno) {\n    if (currentMarker != null) {\n      // Record the name as both a SourcePosition<String> and a\n      // SourcePosition<Node>. The <String> form is deprecated,\n      // because <Node> is more consistent with how other name\n      // references are handled (see #markTypeNode)\n      //\n      // TODO(nicksantos): Remove all uses of the Name position\n      // and replace them with the NameNode position.\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(name);\n      position.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setName(position);\n\n      SourcePosition<Node> nodePos =\n          new JSDocInfo.NamePosition();\n      Node node = Node.newString(Token.NAME, name, lineno, charno);\n      node.setLength(name.length());\n      node.setStaticSourceFile(file);\n      nodePos.setItem(node);\n      nodePos.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setNameNode(nodePos);\n    }\n  }",
    "comment": " Adds a name declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markTypeNode",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(Node,int,int,int,int,boolean)",
    "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n      int endLineno, int endCharno, boolean hasLC) {\n    if (currentMarker != null) {\n      JSDocInfo.TypePosition position = new JSDocInfo.TypePosition();\n      position.setItem(typeNode);\n      position.setHasBrackets(hasLC);\n      position.setPositionInformation(lineno, startCharno,\n          endLineno, endCharno);\n      currentMarker.setType(position);\n    }\n  }",
    "comment": " Adds a type declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.populateDefaults",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(JSDocInfo)",
    "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }",
    "comment": "Generate defaults when certain parameters are not specified. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
    "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isConstructor()} flag set to {@code true}.  @return {@code true} if the constructor was recorded and {@code false} if it was already defined or it was incompatible with the existing flags ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordOriginalCommentString",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordOriginalCommentString(String)",
    "snippet": "  public void recordOriginalCommentString(String sourceComment) {\n    if (parseDocumentation) {\n      currentInfo.setOriginalCommentString(sourceComment);\n    }\n  }",
    "comment": " Sets the original JSDoc comment string. This is a no-op if the builder isn't configured to record documentation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordParameter",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(String,JSTypeExpression)",
    "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a typed parameter.  @return {@code true} if the typed parameter was recorded and {@code false} if a parameter with the same name was already defined ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordReturnType(JSTypeExpression)",
    "snippet": "  public boolean recordReturnType(JSTypeExpression jsType) {\n    if (jsType != null && currentInfo.getReturnType() == null &&\n        !hasAnySingletonTypeTags()) {\n      currentInfo.setReturnType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a return type.  @return {@code true} if the return type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordType(JSTypeExpression)",
    "snippet": "  public boolean recordType(JSTypeExpression type) {\n    if (type != null && !hasAnyTypeRelatedTags()) {\n      currentInfo.setType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a type.  @return {@code true} if the type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.shouldParseDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.shouldParseDocumentation()",
    "snippet": "  public boolean shouldParseDocumentation() {\n    return parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.JSTypeExpression",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(Node,String)",
    "snippet": "  public JSTypeExpression(Node root, String sourceName) {\n    this.root = root;\n    this.sourceName = sourceName;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.evaluate",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.evaluate(StaticScope,JSTypeRegistry)",
    "snippet": "  public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n    root.setJSType(type);\n    return type;\n  }",
    "comment": " Evaluates the type expression into a {@code JSType} object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isOptionalArg",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
    "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }",
    "comment": " @return Whether this expression denotes an optional {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isVarArgs",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }",
    "comment": " @return Whether this expression denotes a rest args {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,int,int)",
    "snippet": "  public Node(int nodeType, Node child, int lineno, int charno) {\n    this(nodeType, child);\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,int,int)",
    "snippet": "  public Node(int nodeType, int lineno, int charno) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.children",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.children()",
    "snippet": "  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }",
    "comment": " <p>Return an iterable object that iterates over this node's children. The iterator does not support the optional operation {@link Iterator#remove()}.</p>  <p>To iterate over a node's siblings, one can write</p> <pre>Node n = ...; for (Node child : n.children()) { ...</pre> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The receiving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,Object,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,int,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getInputId()",
    "snippet": "  public InputId getInputId() {\n    return ((InputId) this.getProp(INPUT_ID));\n  }",
    "comment": " @return The Id of the CompilerInput associated with this Node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
    "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.getIntValue();\n  }",
    "comment": " Returns the integer value for the property, or 0 if the property is not defined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "  public JSType getJSType() {\n      return jsType;\n  }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "  public Node getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    if (propType == SOURCENAME_PROP) {\n      return getSourceFileName();\n    }\n\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getQualifiedName()",
    "snippet": "  public String getQualifiedName() {\n    if (type == Token.NAME) {\n      String name = getString();\n      return name.isEmpty() ? null : name;\n    } else if (type == Token.GETPROP) {\n      String left = getFirstChild().getQualifiedName();\n      if (left == null) {\n        return null;\n      }\n      return left + \".\" + getLastChild().getString();\n    } else if (type == Token.THIS) {\n      return \"this\";\n    } else {\n      return null;\n    }\n  }",
    "comment": " This function takes a set of GETPROP nodes and produces a string that is each property separated by dots. If the node ultimately under the left sub-tree is not a simple name, this is not a valid qualified name.  @return a null if this is not a qualified name, or a dot-separated string of the name and properties. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getSourceFileName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
    "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
    "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }",
    "comment": "Returns the source file associated with this input. May be null */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChild(Node)",
    "snippet": "  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Intended for testing and verification only.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasChildren",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChildren()",
    "snippet": "  public boolean hasChildren() {\n    return first != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasMoreThanOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasMoreThanOneChild()",
    "snippet": "  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }",
    "comment": " Check for more than one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node more than one child. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isAssign",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isAssign()",
    "snippet": "  public boolean isAssign() {\n    return this.getType() == Token.ASSIGN;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isBlock()",
    "snippet": "  public boolean isBlock() {\n    return this.getType() == Token.BLOCK;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isCatch",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isCatch()",
    "snippet": "  public boolean isCatch() {\n    return this.getType() == Token.CATCH;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isDec",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isDec()",
    "snippet": "  public boolean isDec() {\n    return this.getType() == Token.DEC;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isExprResult",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isExprResult()",
    "snippet": "  public boolean isExprResult() {\n    return this.getType() == Token.EXPR_RESULT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isFor",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isFor()",
    "snippet": "  public boolean isFor() {\n    return this.getType() == Token.FOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isFromExterns",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isFromExterns()",
    "snippet": "  public boolean isFromExterns() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? false : file.isExtern();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isFunction",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isFunction()",
    "snippet": "  public boolean isFunction() {\n    return this.getType() == Token.FUNCTION;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isGetElem",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isGetElem()",
    "snippet": "  public boolean isGetElem() {\n    return this.getType() == Token.GETELEM;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isGetProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isGetProp()",
    "snippet": "  public boolean isGetProp() {\n    return this.getType() == Token.GETPROP;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isInc",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isInc()",
    "snippet": "  public boolean isInc() {\n    return this.getType() == Token.INC;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isName()",
    "snippet": "  public boolean isName() {\n    return this.getType() == Token.NAME;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isObjectLit",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isObjectLit()",
    "snippet": "  public boolean isObjectLit() {\n    return this.getType() == Token.OBJECTLIT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isOptionalArg()",
    "snippet": "  public boolean isOptionalArg() {\n    return getBooleanProp(OPT_ARG_NAME);\n  }",
    "comment": " Returns whether this node is an optional argument node. This method's return value is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isParamList",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isParamList()",
    "snippet": "  public boolean isParamList() {\n    return this.getType() == Token.PARAM_LIST;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
    "snippet": "  public boolean isQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n        return getString().isEmpty() ? false : true;\n      case Token.THIS:\n        return true;\n      case Token.GETPROP:\n        return getFirstChild().isQualifiedName();\n      default:\n        return false;\n    }\n  }",
    "comment": " Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isReturn",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isReturn()",
    "snippet": "  public boolean isReturn() {\n    return this.getType() == Token.RETURN;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isScript",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isScript()",
    "snippet": "  public boolean isScript() {\n    return this.getType() == Token.SCRIPT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isString()",
    "snippet": "  public boolean isString() {\n    return this.getType() == Token.STRING;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
    "snippet": "  public boolean isSyntheticBlock() {\n    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n  }",
    "comment": " Returns whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isThis",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isThis()",
    "snippet": "  public boolean isThis() {\n    return this.getType() == Token.THIS;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isThrow",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isThrow()",
    "snippet": "  public boolean isThrow() {\n    return this.getType() == Token.THROW;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isTrue",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isTrue()",
    "snippet": "  public boolean isTrue() {\n    return this.getType() == Token.TRUE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isTry",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isTry()",
    "snippet": "  public boolean isTry() {\n    return this.getType() == Token.TRY;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isUnscopedQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isUnscopedQualifiedName()",
    "snippet": "  public boolean isUnscopedQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n        return getString().isEmpty() ? false : true;\n      case Token.GETPROP:\n        return getFirstChild().isUnscopedQualifiedName();\n      default:\n        return false;\n    }\n  }",
    "comment": " Returns whether a node corresponds to a simple or a qualified name without a \"this\" reference, such as <code>a.b.c</code>, but not <code>this.a</code> . ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isVar",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isVar()",
    "snippet": "  public boolean isVar() {\n    return this.getType() == Token.VAR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.isVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return getBooleanProp(VAR_ARGS_NAME);\n  }",
    "comment": " Returns whether this node is a variable length argument node. This method's return value is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.newNumber",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newNumber(double)",
    "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(String,int,int)",
    "snippet": "  public static Node newString(String str, int lineno, int charno) {\n    return new StringNode(Token.STRING, str, lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    if (propType == SOURCENAME_PROP) {\n      putProp(\n          STATIC_SOURCE_FILE, new SimpleSourceFile((String) value, false));\n      return;\n    }\n\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setInputId(InputId)",
    "snippet": "  public void setInputId(InputId inputId) {\n    this.putProp(INPUT_ID, inputId);\n  }",
    "comment": " @param inputId ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n  }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setLength",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLength(int)",
    "snippet": "  public void setLength(int length) {\n    putIntProp(LENGTH, length);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(StaticSourceFile)",
    "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getNext",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getNext()",
    "snippet": "    @Override\n    public PropListItem getNext() {\n      return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getType",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getType()",
    "snippet": "    @Override\n    public int getType() {\n      return propType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IntPropListItem.chain",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.chain(PropListItem)",
    "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "IntPropListItem.getIntValue",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.getIntValue()",
    "snippet": "    @Override\n    public int getIntValue() {\n      return intValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectPropListItem.getObjectValue",
    "class_name": "com.google.javascript.rhino.Node$ObjectPropListItem",
    "signature": "com.google.javascript.rhino.Node$ObjectPropListItem.getObjectValue()",
    "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.hasNext",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.hasNext()",
    "snippet": "    @Override\n    public boolean hasNext() {\n      return current != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.iterator",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.iterator()",
    "snippet": "    @Override\n    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.next",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.next()",
    "snippet": "    @Override\n    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }",
    "comment": " returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments) {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Locale locale = Locale.getDefault();\n\n        // ResourceBundle does caching.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticeable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId) {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AllType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hasAnyTemplateInternal",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hasAnyTemplateInternal()",
    "snippet": "  @Override\n  public boolean hasAnyTemplateInternal() {\n    return returnType.hasAnyTemplate()\n        || hasTemplatedParameterType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hasEqualParameters",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hasEqualParameters(ArrowType)",
    "snippet": "  boolean hasEqualParameters(ArrowType that) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.isEquivalentTo(otherParamType)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
    "comment": " @return True if our parameter spec is equal to {@code that}'s parameter spec. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hasTemplatedParameterType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hasTemplatedParameterType()",
    "snippet": "  private boolean hasTemplatedParameterType() {\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        JSType type = paramNode.getJSType();\n        if (type != null && type.hasAnyTemplate()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (returnTypeInferred) {\n      hashCode += 1;\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType object) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!(object instanceof ArrowType)) {\n      return false;\n    }\n    ArrowType that = (ArrowType) object;\n    if (!returnType.isEquivalentTo(that.returnType)) {\n      return false;\n    }\n    return hasEqualParameters(that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n\n    ArrowType that = (ArrowType) other;\n\n    // This is described in Draft 2 of the ES4 spec,\n    // Section 3.4.7: Subtyping Function Types.\n\n    // this.returnType <: that.returnType (covariant)\n    if (!this.returnType.isSubtype(that.returnType)) {\n      return false;\n    }\n\n    // that.paramType[i] <: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don't have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g < f, but f !< g\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n      if (thisParamType != null) {\n        if (thatParamType == null ||\n            !thatParamType.isSubtype(thisParamType)) {\n          return false;\n        }\n      }\n\n      boolean thisIsVarArgs = thisParam.isVarArgs();\n      boolean thatIsVarArgs = thatParam.isVarArgs();\n      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n\n      // \"that\" can't be a supertype, because it's missing a required argument.\n      if (!thisIsOptional && thatIsOptional) {\n        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n        // {function(...NoType)} to to indicate that arity should not be\n        // checked. Strictly speaking, this is not a correct formulation,\n        // because now a sub-function can required arguments that are var_args\n        // in the super-function. So we special-case this.\n        boolean isTopFunction =\n            thatIsVarArgs &&\n            (thatParamType == null ||\n             thatParamType.isUnknownType() ||\n             thatParamType.isNoType());\n        if (!isTopFunction) {\n          return false;\n        }\n      }\n\n      // don't advance if we have variable arguments\n      if (!thisIsVarArgs) {\n        thisParam = thisParam.getNext();\n      }\n      if (!thatIsVarArgs) {\n        thatParam = thatParam.getNext();\n      }\n\n      // both var_args indicates the end\n      if (thisIsVarArgs && thatIsVarArgs) {\n        thisParam = null;\n        thatParam = null;\n      }\n    }\n\n    // \"that\" can't be a supertype, because it's missing a required argument.\n    if (thisParam != null\n        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n        && thatParam == null) {\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    returnType = safeResolve(returnType, t, scope);\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n      }\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeNames, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.forNativeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.forNativeType()",
    "snippet": "  FunctionBuilder forNativeType() {\n    this.isNativeType = true;\n    return this;\n  }",
    "comment": "Make this a native type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withName(String)",
    "snippet": "  public FunctionBuilder withName(String name) {\n    this.name = name;\n    return this;\n  }",
    "comment": "Set the name of the function type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType,boolean)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n    this.returnType = returnType;\n    this.inferredReturnType = inferred;\n    return this;\n  }",
    "comment": "Set the return type and whether it's inferred. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withSourceNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withSourceNode(Node)",
    "snippet": "  public FunctionBuilder withSourceNode(Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }",
    "comment": "Set the source node of the function type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withTemplateNames",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTemplateNames(ImmutableList)",
    "snippet": "  public FunctionBuilder withTemplateNames(\n      ImmutableList<String> templateTypeNames) {\n    this.templateTypeNames = templateTypeNames;\n    return this;\n  }",
    "comment": "Set the template name. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withTypeOfThis",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTypeOfThis(ObjectType)",
    "snippet": "  public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {\n    this.typeOfThis = typeOfThis;\n    return this;\n  }",
    "comment": "Set the \"this\" type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefine-able. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameterFromNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameterFromNode(Node)",
    "snippet": "  public Node newParameterFromNode(Node n) {\n    Node newParam = newParameter(n.getJSType());\n    newParam.setVarArgs(n.isVarArgs());\n    newParam.setOptionalArg(n.isOptionalArg());\n    return newParam;\n  }",
    "comment": " Copies the parameter specification from the given node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,ImmutableList,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n               ArrowType arrowType, ObjectType typeOfThis,\n               ImmutableList<String> templateTypeNames,\n               boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    setPrettyPrint(true);\n\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    if (isConstructor) {\n      this.kind = Kind.CONSTRUCTOR;\n      this.propAccess = PropAccess.ANY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.kind = Kind.ORDINARY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeNames = templateTypeNames != null\n        ? templateTypeNames : ImmutableList.<String>of();\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getAllImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getAllImplementedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getAllImplementedInterfaces() {\n    // Store them in a linked hash set, so that the compile job is\n    // deterministic.\n    Set<ObjectType> interfaces = Sets.newLinkedHashSet();\n\n    for (ObjectType type : getImplementedInterfaces()) {\n      addRelatedInterfaces(type, interfaces);\n    }\n    return interfaces;\n  }",
    "comment": " Returns all interfaces implemented by a class or its superclass and any superclasses for any of those interfaces. If this is called before all types are resolved, it may return an incomplete set. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }",
    "comment": "Returns interfaces directly extended by an interface */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getImplementedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getImplementedInterfaces() {\n    FunctionType superCtor = isConstructor() ?\n        getSuperClassConstructor() : null;\n    if (superCtor == null) {\n      return implementedInterfaces;\n    } else {\n      return Iterables.concat(\n          implementedInterfaces, superCtor.getImplementedInterfaces());\n    }\n  }",
    "comment": "Returns interfaces implemented directly by a class or its superclass. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getParameters",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getParameters()",
    "snippet": "  public Iterable<Node> getParameters() {\n    Node n = getParametersNode();\n    if (n != null) {\n      return n.children();\n    } else {\n      return Collections.emptySet();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getParametersNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getParametersNode()",
    "snippet": "  public Node getParametersNode() {\n    return call.parameters;\n  }",
    "comment": "Gets an LP node that contains all params. May be null. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String name) {\n    if (!hasOwnProperty(name)) {\n      // Define the \"call\", \"apply\", and \"bind\" functions lazily.\n      boolean isCall = \"call\".equals(name);\n      boolean isBind = \"bind\".equals(name);\n      if (isCall || isBind) {\n        defineDeclaredProperty(name, getCallOrBindSignature(isCall), source);\n      } else if (\"apply\".equals(name)) {\n        // Define the \"apply\" function lazily.\n        FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n\n        // ECMA-262 says that apply's second argument must be an Array\n        // or an arguments object. We don't model the arguments object,\n        // so let's just be forgiving for now.\n        // TODO(nicksantos): Model the Arguments object.\n        builder.addOptionalParams(\n            registry.createNullableType(getTypeOfThis()),\n            registry.createNullableType(\n                registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n\n        defineDeclaredProperty(name,\n            new FunctionBuilder(registry)\n            .withParams(builder)\n            .withReturnType(getReturnType())\n            .build(),\n            source);\n      }\n    }\n\n    return super.getPropertyType(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public ObjectType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototypeSlot == null) {\n      String refName = getReferenceName();\n      if (refName == null) {\n        // Someone is trying to access the prototype of a structural function.\n        // We don't want to give real properties to this prototype, because\n        // then it would propagate to all structural functions.\n        setPrototypeNoCheck(\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),\n           null);\n      } else {\n        setPrototype(\n            new PrototypeObjectType(\n                registry,\n                this.getReferenceName() + \".prototype\",\n                registry.getNativeObjectType(OBJECT_TYPE),\n                isNativeObjectType()),\n            null);\n      }\n    }\n    return (ObjectType) prototypeSlot.getType();\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getReturnType()",
    "snippet": "  public JSType getReturnType() {\n    return call.returnType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSlot",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSlot(String)",
    "snippet": "  @Override\n  public Property getSlot(String name) {\n    if (\"prototype\".equals(name)) {\n      // Lazy initialization of the prototype field.\n      getPrototype();\n      return prototypeSlot;\n    } else {\n      return super.getSlot(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSource",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSource()",
    "snippet": "  public Node getSource() {\n    return source;\n  }",
    "comment": " Gets the source node or null if this is an unknown function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getTemplateTypeNames",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getTemplateTypeNames()",
    "snippet": "  public ImmutableList<String> getTemplateTypeNames() {\n    return templateTypeNames;\n  }",
    "comment": " Gets the template type name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getTypeOfThis",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getTypeOfThis()",
    "snippet": "  @Override\n  public ObjectType getTypeOfThis() {\n    return typeOfThis.isNoObjectType() ?\n        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;\n  }",
    "comment": " Gets the type of {@code this} in this function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasAnyTemplateInternal",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasAnyTemplateInternal()",
    "snippet": "  @Override\n  public boolean hasAnyTemplateInternal() {\n    return !getTemplateTypeNames().isEmpty()\n        || typeOfThis.hasAnyTemplate()\n        || call.hasAnyTemplate();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototypeSlot != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasEqualCallType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasEqualCallType(FunctionType)",
    "snippet": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.isEquivalentTo(otherType.call);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    FunctionType that =\n        JSType.toMaybeFunctionType(otherType);\n    if (that == null) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }",
    "comment": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInstanceType()",
    "snippet": "  @Override\n  public boolean isInstanceType() {\n    // The universal constructor is its own instance, bizarrely.\n    return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isReturnTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isReturnTypeInferred()",
    "snippet": "  public boolean isReturnTypeInferred() {\n    return call.returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      FunctionType other = that.toMaybeFunctionType();\n      if (other.isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }",
    "comment": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.makesDicts",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.makesDicts()",
    "snippet": "  public boolean makesDicts() {\n    if (!isConstructor()) {\n      return false;\n    }\n    if (propAccess == PropAccess.DICT) {\n      return true;\n    }\n    FunctionType superc = getSuperClassConstructor();\n    if (superc != null && superc.makesDicts()) {\n      setDict();\n      return true;\n    }\n    return false;\n  }",
    "comment": " When a class B inherits from A and A is annotated as a dict, then B automatically gets the annotation, even if B's constructor is not explicitly annotated. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    if (prototypeSlot != null) {\n      prototypeSlot.setType(\n          safeResolve(prototypeSlot.getType(), t, scope));\n    }\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the run-time coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(\n            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setImplementedInterfaces(List)",
    "snippet": "  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n    // Records this type for each implemented interface.\n    for (ObjectType type : implementedInterfaces) {\n      registry.registerTypeImplementingInterface(this, type);\n    }\n    this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(ObjectType,Node)",
    "snippet": "  boolean setPrototype(ObjectType prototype, Node propertyNode) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n    return setPrototypeNoCheck(prototype, propertyNode);\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    setPrototypeBasedOn(baseType, null);\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType,Node)",
    "snippet": "  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype(baseType, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeNoCheck",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeNoCheck(ObjectType,Node)",
    "snippet": "  private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) {\n    ObjectType oldPrototype = prototypeSlot == null\n        ? null : (ObjectType) prototypeSlot.getType();\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n        propertyNode == null ? source : propertyNode);\n    prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": "Set the prototype without doing any sanity checks. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setSource",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setSource(Node)",
    "snippet": "  public void setSource(Node source) {\n    if (prototypeSlot != null) {\n      // NOTE(bashir): On one hand when source is null we want to drop any\n      // references to old nodes retained in prototypeSlot. On the other hand\n      // we cannot simply drop prototypeSlot, so we retain all information\n      // except the propertyNode for which we use an approximation! These\n      // details mostly matter in hot-swap passes.\n      if (source == null || prototypeSlot.getNode() == null) {\n        prototypeSlot = new Property(prototypeSlot.getName(),\n            prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source);\n      }\n    }\n    this.source = source;\n  }",
    "comment": " Sets the source node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.toMaybeFunctionType()",
    "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isInstanceType()",
    "snippet": "  @Override\n  public boolean isInstanceType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toStringHelper(forAnnotations);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.autobox",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.autobox()",
    "snippet": "  public JSType autobox() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return autobox == null ? restricted : autobox;\n  }",
    "comment": " Dereference a type for property access.  Filters null/undefined and autoboxes the resulting type. Never returns null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.autoboxesTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.autoboxesTo()",
    "snippet": "  public JSType autoboxesTo() {\n    return null;\n  }",
    "comment": " Turn a scalar type to the corresponding object type.  @return the auto-boxed type or {@code null} if this type is not a scalar. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.canAssignTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.canAssignTo(JSType)",
    "snippet": "  public boolean canAssignTo(JSType that) {\n    if (this.isSubtype(that)) {\n      return true;\n    }\n    return false;\n  }",
    "comment": " Tests whether values of {@code this} type can be safely assigned to values of {@code that} type.<p>  The default implementation verifies that {@code this} is a subtype of {@code that}.<p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.dereference",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.dereference()",
    "snippet": "  public final ObjectType dereference() {\n    return autobox().toObjectType();\n  }",
    "comment": " Dereference a type for property access.  Filters null/undefined, autoboxes the resulting type, and returns it iff it's an object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.filterNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.filterNoResolvedType(JSType)",
    "snippet": "  static JSType filterNoResolvedType(JSType type) {\n    if (type.isNoResolvedType()) {\n      // inf(UnresolvedType1, UnresolvedType2) needs to resolve\n      // to the base unresolved type, so that the relation is symmetric.\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      boolean needsFiltering = false;\n      for (JSType alt : unionType.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          needsFiltering = true;\n          break;\n        }\n      }\n\n      if (needsFiltering) {\n        UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);\n        for (JSType alt : unionType.getAlternates()) {\n          if (!alt.isNoResolvedType()) {\n            builder.addAlternate(alt);\n          }\n        }\n        return builder.build();\n      }\n    }\n    return type;\n  }",
    "comment": " When computing infima, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another.  If this happens, filter them down to NoResolvedType. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.findPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.findPropertyType(String)",
    "snippet": "  public JSType findPropertyType(String propertyName) {\n    ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());\n    if (autoboxObjType != null) {\n      return autoboxObjType.findPropertyType(propertyName);\n    }\n\n    return null;\n  }",
    "comment": " Coerces this type to an Object type, then gets the type of the property whose name is given.  Unlike {@link ObjectType#getPropertyType}, returns null if the property is not found.  @return The property's type. {@code null} if the current type cannot have properties, or if the type is not found. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return null;\n  }",
    "comment": " Gets the docInfo for this type. By default, documentation cannot be attached to arbitrary types. This must be overridden for programmer-defined types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getLeastSupertype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(JSType)",
    "snippet": "  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.toMaybeUnionType().getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }",
    "comment": " Gets the least supertype of {@code this} and {@code that}. The least supertype is the join (&#8744;) or supremum of both types in the type lattice.<p> Examples: <ul> <li>{@code number &#8744; *} = {@code *}</li> <li>{@code number &#8744; Object} = {@code (number, Object)}</li> <li>{@code Number &#8744; Object} = {@code Object}</li> </ul> @return {@code this &#8744; that} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getLeastSupertype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(JSType,JSType)",
    "snippet": "  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    boolean areEquivalent = thisType.isEquivalentTo(thatType);\n    return areEquivalent ? thisType :\n        filterNoResolvedType(\n            thisType.registry.createUnionType(thisType, thatType));\n  }",
    "comment": " A generic implementation meant to be used as a helper for common getLeastSupertype implementations. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hasAnyTemplate",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplate()",
    "snippet": "  public boolean hasAnyTemplate() {\n    if (!this.inTemplatedCheckVisit) {\n      this.inTemplatedCheckVisit = true;\n      boolean result = hasAnyTemplateInternal();\n      this.inTemplatedCheckVisit = false;\n      return result;\n    } else {\n      // prevent infinite recursion, this is \"not yet\".\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hasAnyTemplateInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplateInternal()",
    "snippet": "  boolean hasAnyTemplateInternal() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return false;\n  }",
    "comment": " Whether this type is a {@link FunctionType} that is a constructor or a named type that points to such a type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isDict",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isDict()",
    "snippet": "  public boolean isDict() {\n    if (isObject()) {\n      FunctionType ctor = toObjectType().getConstructor();\n      return ctor != null && ctor.makesDicts();\n    }\n    return false;\n  }",
    "comment": " Returns true iff {@code this} can be a {@code dict}. UnionType overrides the method, assume {@code this} is not a union here. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEnumType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEnumType()",
    "snippet": "  public boolean isEnumType() {\n    return toMaybeEnumType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionType()",
    "snippet": "  public final boolean isFunctionType() {\n    return toMaybeFunctionType() != null;\n  }",
    "comment": "Returns true if toMaybeFunctionType returns a non-null FunctionType. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isInstanceType()",
    "snippet": "  public boolean isInstanceType() {\n    return false;\n  }",
    "comment": " Whether this type is an Instance object of some constructor. Does not necessarily mean this is an {@link InstanceObjectType}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return false;\n  }",
    "comment": " Whether this type is a {@link FunctionType} that is an interface or a named type that points to such a type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
    "snippet": "  public boolean isNominalType() {\n    return false;\n  }",
    "comment": " Whether this type is a nominal type (a named instance object or a named enum). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isObject",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isObject()",
    "snippet": "  public boolean isObject() {\n    return false;\n  }",
    "comment": " Tests whether this type is an {@code Object}, or any subtype thereof. @return {@code this &lt;: Object} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isRecordType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isRecordType()",
    "snippet": "  public boolean isRecordType() {\n    return toMaybeRecordType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType)",
    "snippet": "  public boolean isSubtype(JSType that) {\n    return isSubtypeHelper(this, that);\n  }",
    "comment": " Checks whether {@code this} is a subtype of {@code that}.<p>  Subtyping rules: <ul> <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li> <li>(no) &mdash; the No type is a subtype of every type.</li> <li>(no-object) &mdash; the NoObject type is a subtype of every object type (i.e. subtypes of the Object type).</li> <li>(ref) &mdash; a type is a subtype of itself.</li> <li>(union-l) &mdash; A union type is a subtype of a type U if all the union type's constituents are a subtype of U. Formally<br> {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li> <li>(union-r) &mdash; A type U is a subtype of a union type if it is a subtype of one of the union type's constituents. Formally<br> {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li> <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype of an object {@code O<sub>2</sub>} if it has more properties than {@code O<sub>2</sub>} and all common properties are pairwise subtypes.</li> </ul>  @return {@code this &lt;: that} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtypeHelper",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtypeHelper(JSType,JSType)",
    "snippet": "  static boolean isSubtypeHelper(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // unions\n    if (thatType.isUnionType()) {\n      UnionType union = thatType.toMaybeUnionType();\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // proxy types\n    if (thatType instanceof ProxyObjectType) {\n      return thisType.isSubtype(\n          ((ProxyObjectType) thatType).getReferencedTypeInternal());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isTemplateType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isTemplateType()",
    "snippet": "  public final boolean isTemplateType() {\n    return toMaybeTemplateType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnionType()",
    "snippet": "  public final boolean isUnionType() {\n    return toMaybeUnionType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.resolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.resolve(ErrorReporter,StaticScope)",
    "snippet": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }",
    "comment": " Resolve this type in the given scope.  The returned value must be equal to {@code this}, as defined by {@link #isEquivalentTo}. It may or may not be the same object. This method may modify the internal state of {@code this}, as long as it does so in a way that preserves Object equality.  For efficiency, we should only resolve a type once per compilation job. For incremental compilations, one compilation job may need the artifacts from a previous generation, so we will eventually need a generational flag instead of a boolean one. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.restrictByNotNullOrUndefined()",
    "snippet": "  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }",
    "comment": " If this is a union type, returns a union type that does not include the null or undefined type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.safeResolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.safeResolve(JSType,ErrorReporter,StaticScope)",
    "snippet": "  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }",
    "comment": " A null-safe resolve. @see #resolve ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.setResolvedTypeInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.setResolvedTypeInternal(JSType)",
    "snippet": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeEnumType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeEnumType()",
    "snippet": "  public EnumType toMaybeEnumType() {\n    return null;\n  }",
    "comment": " Downcasts this to an EnumType, or returns null if this is not an EnumType. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType()",
    "snippet": "  public FunctionType toMaybeFunctionType() {\n    return null;\n  }",
    "comment": " Downcasts this to a FunctionType, or returns null if this is not a function.  For the purposes of this function, we define a MaybeFunctionType as any type in the sub-lattice { x | LEAST_FUNCTION_TYPE <= x <= GREATEST_FUNCTION_TYPE } This definition excludes bottom types like NoType and NoObjectType.  This definition is somewhat arbitrary and axiomatic, but this is the definition that makes the most sense for the most callers. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType(JSType)",
    "snippet": "  public static FunctionType toMaybeFunctionType(JSType type) {\n    return type == null ? null : type.toMaybeFunctionType();\n  }",
    "comment": " Null-safe version of toMaybeFunctionType(). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeRecordType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeRecordType()",
    "snippet": "  RecordType toMaybeRecordType() {\n    return null;\n  }",
    "comment": " Downcasts this to a RecordType, or returns null if this is not a RecordType. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeTemplateType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeTemplateType()",
    "snippet": "  public TemplateType toMaybeTemplateType() {\n    return null;\n  }",
    "comment": " Downcasts this to a TemplateType, or returns null if this is not a function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeUnionType()",
    "snippet": "  public UnionType toMaybeUnionType() {\n    return null;\n  }",
    "comment": " Downcasts this to a UnionType, or returns null if this is not a UnionType.  Named in honor of Haskell's Maybe type constructor. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType. If this is a scalar type, it will *not* be converted to an object type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toString",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return toStringHelper(false);\n  }",
    "comment": " A string representation of this type, suitable for printing in warnings. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.clearTemplateTypeNames",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.clearTemplateTypeNames()",
    "snippet": "  public void clearTemplateTypeNames() {\n    templateTypes.clear();\n  }",
    "comment": " Clears the template type name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createConstructorType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createConstructorType(String,Node,Node,JSType)",
    "snippet": "  public FunctionType createConstructorType(String name, Node source,\n      Node parameters, JSType returnType) {\n    return new FunctionType(this, name, source,\n        createArrowType(parameters, returnType), null,\n        null, true, false);\n  }",
    "comment": " Creates a constructor function type. @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createDefaultObjectUnion",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createDefaultObjectUnion(JSType)",
    "snippet": "  public JSType createDefaultObjectUnion(JSType type) {\n    if (type.isTemplateType()) {\n      // Template types represent the substituted type exactly and should\n      // not be wrapped.\n      return type;\n    } else {\n      return shouldTolerateUndefinedValues()\n        ? createOptionalNullableType(type)\n        : createNullableType(type);\n    }\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFromTypeNodes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodes(Node,String,StaticScope)",
    "snippet": "  public JSType createFromTypeNodes(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n      // If the type expression doesn't contain any names, just\n      // resolve it anyway.\n      boolean hasNames = hasTypeName(n);\n      if (hasNames) {\n        return new UnresolvedTypeExpression(this, n, sourceName);\n      }\n    }\n    return createFromTypeNodesInternal(n, sourceName, scope);\n  }",
    "comment": " Creates a JSType from the nodes representing a type. @param n The node with type info. @param sourceName The source file name. @param scope A scope for doing type name lookups. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFromTypeNodesInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodesInternal(Node,String,StaticScope)",
    "snippet": "  private JSType createFromTypeNodesInternal(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    switch (n.getType()) {\n      case Token.LC: // Record type.\n        return createRecordTypeFromNodes(\n            n.getFirstChild(), sourceName, scope);\n\n      case Token.BANG: // Not nullable\n        return createFromTypeNodesInternal(\n            n.getFirstChild(), sourceName, scope)\n            .restrictByNotNullOrUndefined();\n\n      case Token.QMARK: // Nullable or unknown\n        Node firstChild = n.getFirstChild();\n        if (firstChild == null) {\n          return getNativeType(UNKNOWN_TYPE);\n        }\n        return createDefaultObjectUnion(\n            createFromTypeNodesInternal(\n                firstChild, sourceName, scope));\n\n      case Token.EQUALS: // Optional\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.ELLIPSIS: // Var args\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.STAR: // The AllType\n        return getNativeType(ALL_TYPE);\n\n      case Token.LB: // Array type\n        // TODO(nicksantos): Enforce membership restrictions on the Array.\n        return getNativeType(ARRAY_TYPE);\n\n      case Token.PIPE: // Union type\n        UnionTypeBuilder builder = new UnionTypeBuilder(this);\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          builder.addAlternate(\n              createFromTypeNodesInternal(child, sourceName, scope));\n        }\n        return builder.build();\n\n      case Token.EMPTY: // When the return value of a function is not specified\n        return getNativeType(UNKNOWN_TYPE);\n\n      case Token.VOID: // Only allowed in the return value of a function.\n        return getNativeType(VOID_TYPE);\n\n      case Token.STRING:\n        JSType namedType = getType(scope, n.getString(), sourceName,\n            n.getLineno(), n.getCharno());\n        if (resolveMode != ResolveMode.LAZY_NAMES) {\n          namedType = namedType.resolveInternal(reporter, scope);\n        }\n        if ((namedType instanceof ObjectType) &&\n            !(nonNullableTypeNames.contains(n.getString()))) {\n          Node typeList = n.getFirstChild();\n          if (typeList != null &&\n              (\"Array\".equals(n.getString()) ||\n               \"Object\".equals(n.getString()))) {\n            JSType parameterType =\n                createFromTypeNodesInternal(\n                    typeList.getLastChild(), sourceName, scope);\n            namedType = new ParameterizedType(\n                this, (ObjectType) namedType, parameterType);\n            if (typeList.hasMoreThanOneChild()) {\n              JSType indexType =\n                  createFromTypeNodesInternal(\n                      typeList.getFirstChild(), sourceName, scope);\n              namedType = new IndexedType(\n                  this, (ObjectType) namedType, indexType);\n            }\n          }\n          return createDefaultObjectUnion(namedType);\n        } else {\n          return namedType;\n        }\n\n      case Token.FUNCTION:\n        ObjectType thisType = null;\n        boolean isConstructor = false;\n        Node current = n.getFirstChild();\n        if (current.getType() == Token.THIS ||\n            current.getType() == Token.NEW) {\n          Node contextNode = current.getFirstChild();\n          thisType =\n              ObjectType.cast(\n                  createFromTypeNodesInternal(\n                      contextNode, sourceName, scope)\n                  .restrictByNotNullOrUndefined());\n          if (thisType == null) {\n            reporter.warning(\n                ScriptRuntime.getMessage0(\n                    current.getType() == Token.THIS ?\n                    \"msg.jsdoc.function.thisnotobject\" :\n                    \"msg.jsdoc.function.newnotobject\"),\n                sourceName,\n                contextNode.getLineno(), contextNode.getCharno());\n          }\n\n          isConstructor = current.getType() == Token.NEW;\n          current = current.getNext();\n        }\n\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n\n        if (current.getType() == Token.PARAM_LIST) {\n          Node args = current.getFirstChild();\n          for (Node arg = current.getFirstChild(); arg != null;\n               arg = arg.getNext()) {\n            if (arg.getType() == Token.ELLIPSIS) {\n              if (arg.getChildCount() == 0) {\n                paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n              } else {\n                paramBuilder.addVarArgs(\n                    createFromTypeNodesInternal(\n                        arg.getFirstChild(), sourceName, scope));\n              }\n            } else {\n              JSType type = createFromTypeNodesInternal(\n                  arg, sourceName, scope);\n              if (arg.getType() == Token.EQUALS) {\n                boolean addSuccess = paramBuilder.addOptionalParams(type);\n                if (!addSuccess) {\n                  reporter.warning(\n                      ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"),\n                      sourceName, arg.getLineno(), arg.getCharno());\n                }\n              } else {\n                paramBuilder.addRequiredParams(type);\n              }\n            }\n          }\n          current = current.getNext();\n        }\n\n        JSType returnType =\n            createFromTypeNodesInternal(current, sourceName, scope);\n\n        return new FunctionBuilder(this)\n            .withParams(paramBuilder)\n            .withReturnType(returnType)\n            .withTypeOfThis(thisType)\n            .setIsConstructor(isConstructor)\n            .build();\n    }\n\n    throw new IllegalStateException(\n        \"Unexpected node in type expression: \" + n.toString());\n  }",
    "comment": "@see #createFromTypeNodes(Node, String, StaticScope) */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionType(JSType,Node)",
    "snippet": "  private FunctionType createNativeFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .forNativeType()\n        .build();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createNativeFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  private FunctionType createNativeFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createNativeFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSTypeNative[])",
    "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the built-in types specified by the arguments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.declareType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.declareType(String,JSType)",
    "snippet": "  public boolean declareType(String name, JSType t) {\n    if (namesToTypes.containsKey(name)) {\n      return false;\n    }\n    register(t, name);\n    return true;\n  }",
    "comment": " Records declared global type names. This makes resolution faster and more robust in the common case.  @param name The name of the type to be recorded. @param t The actual type being associated with the name. @return True if this name is not already defined, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getErrorReporter",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getErrorReporter()",
    "snippet": "  public ErrorReporter getErrorReporter() {\n    return reporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(StaticScope,String,String,int,int)",
    "snippet": "  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno) {\n    JSType type = getType(jsTypeName);\n    if (type == null) {\n      // TODO(user): Each instance should support named type creation using\n      // interning.\n      NamedType namedType =\n          new NamedType(this, jsTypeName, sourceName, lineno, charno);\n      unresolvedNamedTypes.put(scope, namedType);\n      type = namedType;\n    }\n    return type;\n  }",
    "comment": " Looks up a type by name. To allow for forward references to types, an unrecognized string has to be bound to a NamedType object that will be resolved later.  @param scope A scope for doing type name resolution. @param jsTypeName The name string. @param sourceName The name of the source file where this reference appears. @param lineno The line number of the reference. @return a NamedType if the string argument is not one of the known types, otherwise the corresponding JSType object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(String)",
    "snippet": "  public JSType getType(String jsTypeName) {\n    // TODO(user): Push every local type name out of namesToTypes so that\n    // NamedType#resolve is correct.\n    TemplateType templateType = templateTypes.get(jsTypeName);\n    if (templateType != null) {\n      return templateType;\n    }\n    return namesToTypes.get(jsTypeName);\n  }",
    "comment": " Looks up a type by name.  @param jsTypeName The name string. @return the corresponding JSType object or {@code null} it cannot be found ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (null,void)\n    JSType NULL_VOID =\n        createUnionType(NULL_TYPE, VOID_TYPE);\n    registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resolveTypesInScope",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resolveTypesInScope(StaticScope)",
    "snippet": "  public void resolveTypesInScope(StaticScope<JSType> scope) {\n    for (NamedType type : unresolvedNamedTypes.get(scope)) {\n      type.resolve(reporter, scope);\n    }\n\n    resolvedNamedTypes.putAll(scope, unresolvedNamedTypes.removeAll(scope));\n\n    if (scope != null && scope.getParentScope() == null) {\n      // By default, the global \"this\" type is just an anonymous object.\n      // If the user has defined a Window type, make the Window the\n      // implicit prototype of \"this\".\n      PrototypeObjectType globalThis = (PrototypeObjectType) getNativeType(\n          JSTypeNative.GLOBAL_THIS);\n      JSType windowType = getType(\"Window\");\n      if (globalThis.isUnknownType()) {\n        ObjectType windowObjType = ObjectType.cast(windowType);\n        if (windowObjType != null) {\n          globalThis.setImplicitPrototype(windowObjType);\n        } else {\n          globalThis.setImplicitPrototype(\n              getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n        }\n      }\n    }\n  }",
    "comment": " Resolve all the unresolved types in the given scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.setTemplateTypeNames",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.setTemplateTypeNames(List)",
    "snippet": "  public void setTemplateTypeNames(List<String> names) {\n    Preconditions.checkNotNull(names);\n    for (String name : names) {\n      templateTypes.put(name, new TemplateType(this, name));\n    }\n  }",
    "comment": " Sets the template type name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.shouldTolerateUndefinedValues",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.shouldTolerateUndefinedValues()",
    "snippet": "  public boolean shouldTolerateUndefinedValues() {\n    return tolerateUndefinedValues;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    // nothing, all properties are defined\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.getOwnPropertyJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getOwnPropertyJSDocInfo(String)",
    "snippet": "  @Override\n  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String propertyName) {\n    // Return the least type to be a proper subtype of all other objects.\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // has all properties, since it is any object\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    return this == that;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.isPropertyTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.isPropertyTypeInferred(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeInferred(String propertyName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NullType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.restrictByNotNullOrUndefined()",
    "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    return registry.getNativeType(JSTypeNative.NO_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NullType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.autoboxesTo",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.autoboxesTo()",
    "snippet": "  @Override\n  public JSType autoboxesTo() {\n    return getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is explicitly declared by the programmer. @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineInferredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineInferredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineInferredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    StaticSlot<JSType> originalSlot = getSlot(propertyName);\n    if (hasProperty(propertyName)) {\n      if (isPropertyTypeDeclared(propertyName)) {\n        // We never want to hide a declared property with an inferred property.\n        return true;\n      }\n      JSType originalType = getPropertyType(propertyName);\n      type = originalType == null ? type :\n          originalType.getLeastSupertype(type);\n    }\n\n    boolean result = defineProperty(propertyName, type, true,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is inferred. @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the inferred definition of property that might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.findPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.findPropertyType(String)",
    "snippet": "  @Override\n  public JSType findPropertyType(String propertyName) {\n    return hasProperty(propertyName) ?\n        getPropertyType(propertyName) : null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.getJSDocInfo()",
    "snippet": "  @Override\n  public JSDocInfo getJSDocInfo() {\n    if (docInfo != null) {\n      return docInfo;\n    } else if (getImplicitPrototype() != null) {\n      return getImplicitPrototype().getJSDocInfo();\n    } else {\n      return super.getJSDocInfo();\n    }\n  }",
    "comment": " Gets the docInfo for this type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached values have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isFunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isFunctionPrototypeType()",
    "snippet": "  @Override\n  public final boolean isFunctionPrototypeType() {\n    return getOwnerFunction() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isObject",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isObject()",
    "snippet": "  @Override\n  public boolean isObject() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n    docInfo = info;\n  }",
    "comment": " Sets the docInfo for this type from the given {@link JSDocInfo}. The {@code JSDocInfo} may be {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getJSDocInfo()",
    "snippet": "    @Override public JSDocInfo getJSDocInfo() {\n      return this.docInfo;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.getName",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getName()",
    "snippet": "    @Override\n    public String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.getNode",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getNode()",
    "snippet": "    @Override\n    public Node getNode() {\n      return propertyNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.getType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getType()",
    "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.isTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.isTypeInferred()",
    "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return inferred;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.setJSDocInfo(JSDocInfo)",
    "snippet": "    void setJSDocInfo(JSDocInfo info) {\n      this.docInfo = info;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.setNode",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.setNode(Node)",
    "snippet": "    public void setNode(Node n) {\n      this.propertyNode = n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Property.setType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.setType(JSType)",
    "snippet": "    void setType(JSType type) {\n      this.type = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred JsDoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getCtorImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorImplementedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getImplementedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getOwnPropertyJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnPropertyJSDocInfo(String)",
    "snippet": "  @Override\n  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getJSDocInfo();\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnerFunction()",
    "snippet": "  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertiesCount",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertiesCount()",
    "snippet": "  @Override\n  public int getPropertiesCount() {\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype == null) {\n      return this.properties.size();\n    }\n    int localCount = 0;\n    for (String property : properties.keySet()) {\n      if (!implicitPrototype.hasProperty(property)) {\n        localCount++;\n      }\n    }\n    return implicitPrototype.getPropertiesCount() + localCount;\n  }",
    "comment": " Gets the number of properties of this object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getSlot",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getSlot(String)",
    "snippet": "  @Override\n  public Property getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      Property prop = implicitPrototype.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n      Property prop = interfaceType.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isUnknownType() || getSlot(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isPropertyTypeDeclared",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPropertyTypeDeclared(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeDeclared(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return !slot.isTypeInferred();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isPropertyTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPropertyTypeInferred(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeInferred(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return slot.isTypeInferred();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    } else if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setOwnerFunction(FunctionType)",
    "snippet": "  @Override\n  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setPrettyPrint",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPrettyPrint(boolean)",
    "snippet": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setPropertyJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPropertyJSDocInfo(String,JSDocInfo)",
    "snippet": "  @Override\n  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (!properties.containsKey(propertyName)) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.get(propertyName);\n      if (property != null) {\n        property.setJSDocInfo(info);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.SimpleSlot",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.SimpleSlot(String,JSType,boolean)",
    "snippet": "  public SimpleSlot(String name, JSType type, boolean inferred) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.getName",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.getType",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.getType()",
    "snippet": "  @Override\n  public JSType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.isTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.isTypeInferred()",
    "snippet": "  @Override\n  public boolean isTypeInferred() {\n    return inferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StringType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.getAlternates",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.getAlternates()",
    "snippet": "  public Iterable<JSType> getAlternates() {\n    return alternates;\n  }",
    "comment": " Gets the alternate types of this union type. @return The alternate types of this union type. The returned set is immutable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    for (JSType t : alternates) {\n      if (t.isUnknownType()) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this); // for circularly defined types.\n\n    boolean changed = false;\n    ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder();\n    for (JSType alternate : alternates) {\n      JSType newAlternate = alternate.resolve(t, scope);\n      changed |= (alternate != newAlternate);\n      resolvedTypes.add(alternate);\n    }\n    if (changed) {\n      Collection<JSType> newAlternates = resolvedTypes.build();\n      Preconditions.checkState(\n          newAlternates.hashCode() == this.hashcode);\n      alternates = newAlternates;\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.restrictByNotNullOrUndefined()",
    "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    UnionTypeBuilder restricted = new UnionTypeBuilder(registry);\n    for (JSType t : alternates) {\n      restricted.addAlternate(t.restrictByNotNullOrUndefined());\n    }\n    return restricted.build();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.toMaybeUnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.toMaybeUnionType()",
    "snippet": "  @Override\n  public UnionType toMaybeUnionType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry,int)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate.isUnionType()) {\n        UnionType union = alternate.toMaybeUnionType();\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Function types are special, because they have their\n        // own bizarre sub-lattice. See the comments on\n        // FunctionType#supAndInf helper and above at functionTypePosition.\n        if (alternate.isFunctionType() && functionTypePosition != -1) {\n          // See the comments on functionTypePosition above.\n          FunctionType other =\n              alternates.get(functionTypePosition).toMaybeFunctionType();\n          FunctionType supremum =\n              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n          alternates.set(functionTypePosition, supremum);\n          result = null;\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        int currentIndex = 0;\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType() ||\n              alternate.hasAnyTemplate() ||\n              current.hasAnyTemplate()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n\n              if (currentIndex == functionTypePosition) {\n                functionTypePosition = -1;\n              } else if (currentIndex < functionTypePosition) {\n                functionTypePosition--;\n                currentIndex--;\n              }\n            }\n          }\n          currentIndex++;\n        }\n\n        if (alternate.isFunctionType()) {\n          // See the comments on functionTypePosition above.\n          Preconditions.checkState(functionTypePosition == -1);\n          functionTypePosition = alternates.size();\n        }\n\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String propertyName) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]